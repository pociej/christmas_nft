"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.importRSACryptoKey = exports.deriveAddress = exports.derivePasswords = exports.decryptHybridString = exports.decryptHybridRaw = exports.encryptHybridString = exports.encryptHybridRaw = exports.decryptKeyWithPrivateKey = exports.decryptStringWithPrivateKey = exports.encryptStringWithPublicKey = exports.decryptRawWithPrivateKey = exports.encryptRawWithPublicKey = exports.generateKeyPair = exports.generateKey = exports.deriveKey = exports.decrypt = exports.encrypt = exports.signString = exports.signHash = exports.digestRaw = exports.digest = exports.importRSAPublicKey = exports.importKeyFromSeed = exports.importKeyFromBase64 = exports.exportKeyToBase64 = void 0;
const libsodium_wrappers_1 = require("libsodium-wrappers");
const encoding_1 = require("./encoding");
const nodeCrypto = __importStar(require("crypto"));
const crypto = (typeof window === 'undefined' ? nodeCrypto.webcrypto : window.crypto);
const HASH_ALGORITHM = 'SHA-256';
const SYMMETRIC_KEY_ALGORITHM = 'AES-GCM';
const SYMMETRIC_KEY_LENGTH = 256;
const ASYMMETRIC_KEY_ALGORITHM = 'RSA-OAEP';
const ASYMMETRIC_PUBLIC_EXPONENT = "AQAB";
const IV_LENGTH = 12;
const KEY_DERIVATION_FUNCTION = 'PBKDF2';
const KEY_DERIVATION_ITERATION_COUNT = 150000;
/**
 * Export CryptoKey object to base64 encoded string
 * @param {CryptoKey} key
 * @returns {Promise.<string>} string containing crypto key
 */
function exportKeyToBase64(key) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const rawKeyBuffer = yield crypto.subtle.exportKey('raw', key);
            return (0, encoding_1.arrayToBase64)(rawKeyBuffer);
        }
        catch (error) {
            throw new Error("Web Crypto key export error: " + error);
        }
    });
}
exports.exportKeyToBase64 = exportKeyToBase64;
/**
 * Import CryptoKey object from base64 encoded string
 * @param {string} keyBase64
 * @returns {Promise.<CryptoKey>} crypto key object
 */
function importKeyFromBase64(keyBase64) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const key = yield crypto.subtle.importKey('raw', (0, encoding_1.base64ToArray)(keyBase64), {
                name: SYMMETRIC_KEY_ALGORITHM,
                length: SYMMETRIC_KEY_LENGTH,
            }, true, ['encrypt', 'decrypt']);
            return key;
        }
        catch (error) {
            throw new Error("Web Crypto key import error: " + error);
        }
    });
}
exports.importKeyFromBase64 = importKeyFromBase64;
/**
 * Import key from a random seed
 * @param {Uint8Array} key
 * @returns {Promise.<CryptoKey>} crypto key object
 */
function importKeyFromSeed(seed) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const seedHash = yield crypto.subtle.digest(HASH_ALGORITHM, seed);
            const key = yield crypto.subtle.importKey('raw', seedHash, {
                name: SYMMETRIC_KEY_ALGORITHM,
                length: SYMMETRIC_KEY_LENGTH,
            }, false, ['encrypt', 'decrypt']);
            return key;
        }
        catch (error) {
            throw new Error("Web Crypto key import error: " + error);
        }
    });
}
exports.importKeyFromSeed = importKeyFromSeed;
/**
 * Signature generation using sodium library: https://github.com/jedisct1/libsodium
 * @param {BufferSource} msgHash buffer message hash to be signed
 * @param {Uint8Array} privateKey private key used to sign message hash
 * @returns {Promise.<string>} signature as base64 string
 */
function signHash(msgHash, privateKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const msgHashByteArray = new Uint8Array(msgHash);
        yield libsodium_wrappers_1.ready;
        const signature = (0, libsodium_wrappers_1.crypto_sign_detached)(msgHashByteArray, privateKey);
        return (0, encoding_1.arrayToBase64)(signature);
    });
}
exports.signHash = signHash;
/**
 * Digest generation
 * @param {string} payload string payload to be signed
 * @returns {Promise.<string>} payload digest as base64 string
 */
function digest(payload) {
    return __awaiter(this, void 0, void 0, function* () {
        return digestRaw((0, encoding_1.stringToArray)(payload));
    });
}
exports.digest = digest;
function digestRaw(payload) {
    return __awaiter(this, void 0, void 0, function* () {
        const msgHash = yield crypto.subtle.digest(HASH_ALGORITHM, payload);
        return (0, encoding_1.arrayToBase64)(msgHash);
    });
}
exports.digestRaw = digestRaw;
/**
 * Signature generation
 * @param {string} payload string payload to be signed
 * @param {Uint8Array} privateKey private key used to sign string payload
 * @returns {Promise.<string>} signature as base64 string
 */
function signString(payload, privateKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const msgHash = yield crypto.subtle.digest(HASH_ALGORITHM, (0, encoding_1.stringToArray)(payload));
        const signature = yield signHash(msgHash, privateKey);
        return signature;
    });
}
exports.signString = signString;
/**
 * Encryption using WebCrypto
 * - generate a random initialization vector (iv)
 * - encrypt plaintext using key and iv
 * @param {Uint8Array} plaintext
 * @param {CryptoKey} key
 * @returns {Promise.<string>} Promise of base64 string represents the ciphertext along with iv
 */
function encrypt(plaintext, key, encode = true) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const iv = crypto.getRandomValues(new Uint8Array(IV_LENGTH));
            const ciphertextArray = yield crypto.subtle.encrypt({
                name: SYMMETRIC_KEY_ALGORITHM,
                iv: iv,
            }, key, plaintext);
            if (encode) {
                return encodePayload(ciphertextArray, iv);
            }
            return {
                ciphertext: ciphertextArray,
                iv: (0, encoding_1.arrayToBase64)(iv),
            };
        }
        catch (error) {
            throw new Error("Web Crypto encryption error: " + error);
        }
    });
}
exports.encrypt = encrypt;
/**
 * Decryption using WebCrypto
 * - decrypt ciphertext using key and iv
 * @param {Object} encryptedPayload
 * @param {CryptoKey} key
 * @returns {Promise.<ArrayBuffer>} Promise of ArrayBuffer represents the plaintext
 */
function decrypt(encryptedPayload, key, decode = true) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const payload = decode ? decodePayload(encryptedPayload) : encryptedPayload;
            const plaintext = yield crypto.subtle.decrypt({
                name: SYMMETRIC_KEY_ALGORITHM,
                iv: payload.iv,
            }, key, payload.ciphertext);
            return plaintext;
        }
        catch (error) {
            throw new Error("Web Crypto decryption error: " + error);
        }
    });
}
exports.decrypt = decrypt;
function encodePayload(ciphertextArray, iv) {
    const encryptedPayload = {
        ciphertext: (0, encoding_1.arrayToBase64)(ciphertextArray),
        iv: (0, encoding_1.arrayToBase64)(iv),
    };
    return (0, encoding_1.jsonToBase64)(encryptedPayload);
}
function decodePayload(payload) {
    const parsedPayload = (0, encoding_1.base64ToJson)(payload);
    const decodedPayload = {
        ciphertext: (0, encoding_1.base64ToArray)(parsedPayload.ciphertext),
        iv: (0, encoding_1.base64ToArray)(parsedPayload.iv)
    };
    return decodedPayload;
}
/**
 * Key derivation using WebCrypto
 * - PBKDF2 with 150000 iterations of SHA-256
 * @param {string} password
 * @param {BufferSource} salt
 * @returns {Promise.<CryptoKey>} Promise of CryptoKey object with AES 256-bit symmetric key
 */
function deriveKey(password, salt) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const keyBase = yield crypto.subtle.importKey('raw', (0, encoding_1.stringToArray)(password), KEY_DERIVATION_FUNCTION, false, ['deriveBits', 'deriveKey']);
            return crypto.subtle.deriveKey({
                name: KEY_DERIVATION_FUNCTION,
                salt: salt,
                iterations: KEY_DERIVATION_ITERATION_COUNT,
                hash: HASH_ALGORITHM,
            }, keyBase, {
                name: SYMMETRIC_KEY_ALGORITHM,
                length: SYMMETRIC_KEY_LENGTH,
            }, false, ['encrypt', 'decrypt']);
        }
        catch (error) {
            throw new Error("Web Crypto key derivation error: " + error);
        }
    });
}
exports.deriveKey = deriveKey;
/**
 * Symmetric key generation
 * - generate an extractable AES 256-bit symmetric key
 * @returns {Promise.<CryptoKey>}
 */
function generateKey() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const key = yield crypto.subtle.generateKey({
                name: SYMMETRIC_KEY_ALGORITHM,
                length: SYMMETRIC_KEY_LENGTH,
            }, true, ['encrypt', 'decrypt']);
            return key;
        }
        catch (error) {
            throw new Error("Web Crypto key generation error: " + error);
        }
    });
}
exports.generateKey = generateKey;
/**
 * Public key pair generation
 * - generate a Curve25519 key pair
 * @returns {Promise.<_sodium.KeyPair>}
 */
function generateKeyPair() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield libsodium_wrappers_1.ready;
            const keyPair = (0, libsodium_wrappers_1.crypto_box_keypair)();
            return keyPair;
        }
        catch (error) {
            throw new Error("Sodium box key pair generation error: " + error);
        }
    });
}
exports.generateKeyPair = generateKeyPair;
function deriveAddress(publicKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const sha512Digest = yield crypto.subtle.digest("SHA-512", publicKey);
        return (0, encoding_1.arrayToBase64)(sha512Digest);
    });
}
exports.deriveAddress = deriveAddress;
/**
 * Encryption using sodium library: https://github.com/jedisct1/libsodium
 * @param {Uint8Array} publicKey public key used to encrypt the data
 * @param {Uint8Array} plaintext raw plaintext byte array
 * @returns {Promise.<string>} Promise of base64 string represents the encrypted payload
 */
function encryptRawWithPublicKey(publicKey, plaintext) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield libsodium_wrappers_1.ready;
            const ephemeralKeyPair = (0, libsodium_wrappers_1.crypto_box_keypair)();
            const nonce = (0, libsodium_wrappers_1.randombytes_buf)(libsodium_wrappers_1.crypto_box_NONCEBYTES);
            const ciphertext = (0, libsodium_wrappers_1.crypto_box_easy)(plaintext, nonce, publicKey, ephemeralKeyPair.privateKey);
            const payload = {
                ciphertext: (0, encoding_1.arrayToBase64)(ciphertext),
                ephemPublicKey: (0, encoding_1.arrayToBase64)(ephemeralKeyPair.publicKey),
                nonce: (0, encoding_1.arrayToBase64)(nonce),
            };
            return (0, encoding_1.jsonToBase64)(payload);
        }
        catch (error) {
            throw new Error("Sodium encryption error: " + error);
        }
    });
}
exports.encryptRawWithPublicKey = encryptRawWithPublicKey;
/**
 * Decryption using sodium library: https://github.com/jedisct1/libsodium
 * @param {Uint8Array} privateKey private key used to decrypt the data
 * @param {string} encryptedPayload base64 string represents the encrypted payload
 * @returns {Promise.<Uint8Array>} Promise of raw plaintext byte array
 */
function decryptRawWithPrivateKey(privateKey, encryptedPayload) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const parsedPayload = (0, encoding_1.base64ToJson)(encryptedPayload);
            const nonce = (0, encoding_1.base64ToArray)(parsedPayload.nonce);
            const ciphertext = (0, encoding_1.base64ToArray)(parsedPayload.ciphertext);
            const ephemPublicKey = (0, encoding_1.base64ToArray)(parsedPayload.ephemPublicKey);
            yield libsodium_wrappers_1.ready;
            const plaintext = (0, libsodium_wrappers_1.crypto_box_open_easy)(ciphertext, nonce, ephemPublicKey, privateKey);
            return plaintext;
        }
        catch (error) {
            throw new Error("Sodium decryption error: " + error);
        }
    });
}
exports.decryptRawWithPrivateKey = decryptRawWithPrivateKey;
function encryptStringWithPublicKey(publicKey, plaintext) {
    return __awaiter(this, void 0, void 0, function* () {
        const ciphertext = yield encryptRawWithPublicKey(publicKey, (0, encoding_1.stringToArray)(plaintext));
        return ciphertext;
    });
}
exports.encryptStringWithPublicKey = encryptStringWithPublicKey;
function decryptStringWithPrivateKey(privateKey, encryptedPayload) {
    return __awaiter(this, void 0, void 0, function* () {
        const plaintext = yield decryptRawWithPrivateKey(privateKey, encryptedPayload);
        return (0, encoding_1.arrayToString)(plaintext);
    });
}
exports.decryptStringWithPrivateKey = decryptStringWithPrivateKey;
/**
   * CryptoKey object encryption
   * - export CryptoKey object to base64 encoded string
   * - encrypts encoded key string with the given public key
   * @param {CryptoKey} key
   * @param {Uint8Array} publicKey
   * @returns {Promise.<string>}
   */
function encryptKeyWithPublicKey(key, publicKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const keyString = yield exportKeyToBase64(key);
        const encryptedKey = yield encryptStringWithPublicKey(publicKey, keyString);
        return encryptedKey;
    });
}
/**
 * CryptoKey object decryption
 * - decrypts encoded key string with the given private key
 * - import CryptoKey object from the encoded string
 * @param {string} encryptedKey
 * @param {Uint8Array} privateKey
 * @returns {Promise.<CryptoKey>}
 */
function decryptKeyWithPrivateKey(encryptedKey, privateKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const decryptedKey = yield decryptStringWithPrivateKey(privateKey, encryptedKey);
        const key = yield importKeyFromBase64(decryptedKey);
        return key;
    });
}
exports.decryptKeyWithPrivateKey = decryptKeyWithPrivateKey;
/**
 * Hybrid encryption
 * - generate a symmetric access key
 * - encrypt data with the access key
 * - encrypt the access key with the public key
 * @param {Uint8Array} plaintext raw plaintext byte array
 * @param {Uint8Array} publicKey public key used to encrypt the data
 * @returns {Promise.<Uint8Array>} Promise of raw plaintext byte array
 */
function encryptHybridRaw(plaintext, publicKey, encode = true, accessKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const key = accessKey || (yield generateKey());
        const encryptedData = yield encrypt(plaintext, key, encode);
        const encAccessKey = yield encryptKeyWithPublicKey(key, publicKey);
        const encryptedPayload = {
            encryptedData: encryptedData,
            encryptedKey: encAccessKey,
            publicKey: (0, encoding_1.arrayToBase64)(publicKey)
        };
        if (encode) {
            return (0, encoding_1.jsonToBase64)(encryptedPayload);
        }
        return encryptedPayload;
    });
}
exports.encryptHybridRaw = encryptHybridRaw;
function encryptHybridString(plaintext, publicKey) {
    return __awaiter(this, void 0, void 0, function* () {
        return encryptHybridRaw((0, encoding_1.stringToArray)(plaintext), publicKey);
    });
}
exports.encryptHybridString = encryptHybridString;
/**
 * Hybrid decryption
 * - decrypt the access key with the private key
 * - decrypt the data with the access key
 * @param {string} encryptedPayload base64 string represents the encrypted payload
 * @param {Uint8Array} privateKey private key used to decrypt the data key
 * @returns {Promise.<ArrayBuffer>} Promise of raw plaintext byte array
 */
function decryptHybridRaw(encryptedPayload, privateKey, decode = true) {
    return __awaiter(this, void 0, void 0, function* () {
        if (encryptedPayload === null)
            return null;
        try {
            const payload = (decode ? (0, encoding_1.base64ToJson)(encryptedPayload) : encryptedPayload);
            const accessKey = yield decryptKeyWithPrivateKey(payload.encryptedKey, privateKey);
            const decryptedDataArray = yield decrypt(payload.encryptedData, accessKey, decode);
            return decryptedDataArray;
        }
        catch (err) {
            throw new Error("Hybrid decryption error: " + err);
        }
    });
}
exports.decryptHybridRaw = decryptHybridRaw;
function decryptHybridString(encryptedPayload, privateKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const decryptedDataArray = yield decryptHybridRaw(encryptedPayload, privateKey, true);
        return (0, encoding_1.arrayToString)(decryptedDataArray);
    });
}
exports.decryptHybridString = decryptHybridString;
/**
 * Derive two passwords from input password
 * @param {string} password
 * @returns {Promise.<{string, string}>} Promise of derived passwords
 */
function derivePasswords(password) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const passwordHashBuffer = yield crypto.subtle.digest("SHA-512", (0, encoding_1.stringToArray)(password));
            const authPasswordBuffer = passwordHashBuffer.slice(0, 32);
            const walletPasswordBuffer = passwordHashBuffer.slice(32, 64);
            const authPassword = (0, encoding_1.arrayToBase64)(authPasswordBuffer);
            const walletPassword = (0, encoding_1.arrayToBase64)(walletPasswordBuffer);
            return { authPassword, walletPassword };
        }
        catch (err) {
            throw new Error("Password derivation error: " + err);
        }
    });
}
exports.derivePasswords = derivePasswords;
const importRSAPublicKey = (publicKey) => __awaiter(void 0, void 0, void 0, function* () {
    if (publicKey) {
        return yield crypto.subtle.importKey("jwk", {
            kty: 'RSA',
            e: ASYMMETRIC_PUBLIC_EXPONENT,
            n: publicKey,
            alg: 'RSA-OAEP-256',
            ext: true
        }, {
            name: ASYMMETRIC_KEY_ALGORITHM,
            hash: {
                name: HASH_ALGORITHM
            },
        }, false, ['encrypt']);
    }
    else {
        return null;
    }
});
exports.importRSAPublicKey = importRSAPublicKey;
const importRSACryptoKey = (jwk) => __awaiter(void 0, void 0, void 0, function* () {
    return yield crypto.subtle.importKey("jwk", jwk, {
        name: ASYMMETRIC_KEY_ALGORITHM,
        hash: {
            name: HASH_ALGORITHM
        },
    }, false, ["decrypt"]);
});
exports.importRSACryptoKey = importRSACryptoKey;
//# sourceMappingURL=functions.js.map