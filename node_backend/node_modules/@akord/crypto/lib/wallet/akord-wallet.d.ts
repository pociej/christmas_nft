import { HDKey } from 'ethereum-cryptography/hdkey';
import { Wallet } from '.';
declare class AkordWallet implements Wallet {
    backupPhrase: string;
    encBackupPhrase: string;
    keyPair: {
        privateKey: Uint8Array;
        publicKey: Uint8Array;
    };
    signingKeyPair: {
        privateKey: Uint8Array;
        publicKey: Uint8Array;
    };
    constructor(backupPhrase: string, encBackupPhrase?: string);
    encrypt(input: Uint8Array): Promise<string>;
    decrypt(input: string): Promise<Uint8Array>;
    encryptToPublicKey(input: Uint8Array, publicKey: Uint8Array): Promise<string>;
    sign(string: string): Promise<string>;
    getAddress(): Promise<string>;
    /**
     * Create the wallet
     * - generate 12 word backup phrase
     * - if provided, encrypt backup phrase with password derived symmetric key
     * - derive wallet keys from backup phrase
     * @param {string} [password]
     * @returns {Promise.<AkordWallet>} Promise of AkordWallet object
     */
    static create(password?: string): Promise<AkordWallet>;
    /**
     * Import the wallet from the encrypted backup phrase
     * - decrypt the encrypted backup phrase with password derived symmetric key
     * - derive wallet keys from backup phrase
     * @param {string} password
     * @param {string} encBackupPhrase
     * @returns {Promise.<AkordWallet>} Promise of AkordWallet object
     */
    static importFromEncBackupPhrase(password: string, encBackupPhrase: string): Promise<AkordWallet>;
    /**
   * Import the wallet from the backup phrase
   * - derive wallet keys from backup phrase
   * @param {string} backupPhrase
   * @returns {Promise.<AkordWallet>} Promise of AkordWallet object
   */
    static importFromBackupPhrase(backupPhrase: string): Promise<AkordWallet>;
    /**
     * Import the wallet from the keystore
     * - retrieve the password derived symmetric key from the keystore
     * - retrieve the encrypted backup phrase from the local storage
     * -
     * @param {string} encBackupPhrase
     * @returns {Promise.<AkordWallet>} Promise of AkordWallet object
     */
    static importFromKeystore(encBackupPhrase: string): Promise<AkordWallet>;
    /**
     * Import the wallet from the backup phrase
     * - encrypt backup phrase with new password derived symmetric key
     * - derive wallet keys from backup phrase
     * @param {string} newPassword
     * @param {string} backupPhrase
     * @returns {Promise.<AkordWallet>} Promise of AkordWallet object
     */
    static recover(newPassword: string, backupPhrase: string): Promise<AkordWallet>;
    static changePassword(oldPassword: string, newPassword: string, encBackupPhrase: string): Promise<AkordWallet>;
    static clear(): Promise<void>;
    static isValidMnemonic(backupPhrase: string): boolean;
    /**
     * Root node derivation from backup phrase
     * - derives the master seed from the backup phrase
     * - derives the root node from the master seed
     * @returns {Promise.<hdkey>} Promise of hdkey object with HD wallet root node
     */
    getRoot(): Promise<HDKey>;
    /**
     * Node derivation from backup phrase and given path
     * @param {string} path
     * @returns {Promise.<hdkey>} Promise of hdkey object with HD wallet node
     */
    getNodeFromPath(path: string): Promise<HDKey>;
    /**
     * Public key derivation for the given path
     * @param {string} path
     * @returns {Promise.<string>} Promise of base64 string represents public key
     */
    getPublicKeyFromPath(path: string): Promise<string>;
    /**
     * Private key derivation for the given path
     * @param {string} path
     * @returns {Promise.<string>} Promise of base64 string represents private key
     */
    getPrivateKeyFromPath(path: string): Promise<string>;
    /**
     * Key pair derivation for the given path
     * @param {string} path
     * @returns {Promise.<{ publicKey: string, privateKey: string }>} Promise of JSON represents key pair
     */
    getKeyPairFromPath(path: string): Promise<{
        publicKey: string;
        privateKey: string;
    }>;
    /**
     * Derive encryption and signing key pair for the wallet
     */
    deriveKeys(): Promise<void>;
    /**
     * Encryption private key
     * @returns {Uint8Array}
     */
    privateKeyRaw(): Uint8Array;
    /**
     * Encryption public key
     * @returns {Uint8Array}
     */
    publicKeyRaw(): Uint8Array;
    /**
     * Encryption private key as a string
     * @returns {string}
     */
    privateKey(): string;
    /**
     * Encryption public key as a string
     * @returns {string}
     */
    publicKey(): string;
    /**
     * Signing private key
     * @returns {Uint8Array}
     */
    signingPrivateKeyRaw(): Uint8Array;
    /**
     * Signing public key
     * @returns {Uint8Array}
     */
    signingPublicKeyRaw(): Uint8Array;
    /**
     * Signing private key as a string
     * @returns {string}
     */
    signingPrivateKey(): string;
    /**
     * Signing public key as a string
     * @returns {string}
     */
    signingPublicKey(): string;
}
export { AkordWallet };
