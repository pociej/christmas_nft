"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MembershipService = exports.activeStatus = void 0;
const constants_1 = require("../constants");
const uuid_1 = require("uuid");
const crypto_1 = require("@akord/crypto");
const service_1 = require("./service");
const membership_1 = require("../types/membership");
const contract_1 = require("../types/contract");
const bad_request_1 = require("../errors/bad-request");
const incorrect_encryption_key_1 = require("../errors/incorrect-encryption-key");
const common_1 = require("./common");
const profile_1 = require("./profile");
const profile_details_1 = require("../types/profile-details");
exports.activeStatus = [constants_1.status.ACCEPTED, constants_1.status.PENDING, constants_1.status.INVITED];
class MembershipService extends service_1.Service {
    constructor() {
        super(...arguments);
        this.objectType = constants_1.objectType.MEMBERSHIP;
        this.defaultListOptions = {
            shouldDecrypt: true,
            filter: {
                or: [
                    { status: { eq: constants_1.status.ACCEPTED } },
                    { status: { eq: constants_1.status.PENDING } }
                ]
            }
        };
        this.defaultGetOptions = {
            shouldDecrypt: true,
        };
    }
    /**
     * @param  {string} membershipId
     * @returns Promise with the decrypted membership
     */
    get(membershipId, options = this.defaultGetOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const getOptions = Object.assign(Object.assign({}, this.defaultGetOptions), options);
            const membershipProto = yield this.api.getMembership(membershipId, getOptions.vaultId);
            return yield this.processMembership(membershipProto, !membershipProto.__public__ && getOptions.shouldDecrypt, membershipProto.__keys__);
        });
    }
    /**
     * @param  {string} vaultId
     * @param  {ListOptions} options
     * @returns Promise with paginated memberships within given vault
     */
    list(vaultId, options = this.defaultListOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const listOptions = Object.assign(Object.assign({}, this.defaultListOptions), options);
            const response = yield this.api.getMembershipsByVaultId(vaultId, listOptions);
            const promises = response.items
                .map((membershipProto) => __awaiter(this, void 0, void 0, function* () {
                return yield this.processMembership(membershipProto, !membershipProto.__public__ && listOptions.shouldDecrypt, membershipProto.__keys__);
            }));
            const { items, errors } = yield (0, common_1.handleListErrors)(response.items, promises);
            return {
                items,
                nextToken: response.nextToken,
                errors
            };
        });
    }
    /**
     * @param  {string} vaultId
     * @param  {ListOptions} options
     * @returns Promise with all memberships within given vault
     */
    listAll(vaultId, options = this.defaultListOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const list = (options) => __awaiter(this, void 0, void 0, function* () {
                return yield this.list(options.vaultId, options);
            });
            return yield (0, common_1.paginate)(list, Object.assign(Object.assign({}, options), { vaultId }));
        });
    }
    /**
     * Invite user with an Akord account
     * @param  {string} vaultId
     * @param  {string} email invitee's email
     * @param  {RoleType} role VIEWER/CONTRIBUTOR/OWNER
     * @param  {MembershipCreateOptions} [options] invitation email message, etc.
     * @returns Promise with new membership id & corresponding transaction id
     */
    invite(vaultId, email, role, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = new MembershipService(this.wallet, this.api);
            yield service.setVaultContext(vaultId);
            service.setActionRef(constants_1.actionRefs.MEMBERSHIP_INVITE);
            service.setFunction(constants_1.functions.MEMBERSHIP_INVITE);
            const membershipId = (0, uuid_1.v4)();
            service.setObjectId(membershipId);
            const { address, publicKey, publicSigningKey } = yield this.api.getUserPublicData(email);
            const state = {
                keys: yield service.prepareMemberKeys(publicKey),
                encPublicSigningKey: yield service.processWriteString(publicSigningKey)
            };
            service.arweaveTags = [new contract_1.Tag(constants_1.protocolTags.MEMBER_ADDRESS, address)]
                .concat(yield service.getTxTags());
            const dataTxId = yield service.uploadState(state);
            const input = {
                function: service.function,
                address,
                role,
                data: dataTxId
            };
            const { id, object } = yield this.api.postContractTransaction(service.vaultId, input, service.arweaveTags, { message: options.message });
            const membership = yield this.processMembership(object, !service.isPublic, service.keys);
            return { membershipId, transactionId: id, object: membership };
        });
    }
    /**
     * Airdrop access to the vault directly through public keys
     * @param  {string} vaultId
     * @param  {{publicKey:string,publicSigningKey:string,role:RoleType}[]} members
     * @returns Promise with new memberships & corresponding transaction id
     */
    airdrop(vaultId, members) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const service = new MembershipService(this.wallet, this.api);
            yield service.setVaultContext(vaultId);
            service.setActionRef("MEMBERSHIP_AIRDROP");
            service.setFunction(constants_1.functions.MEMBERSHIP_ADD);
            const memberArray = [];
            const membersMetadata = [];
            const dataArray = [];
            const memberTags = [];
            for (const member of members) {
                const membershipId = (0, uuid_1.v4)();
                service.setObjectId(membershipId);
                const memberAddress = yield (0, crypto_1.deriveAddress)((0, crypto_1.base64ToArray)(member.publicSigningKey));
                const state = {
                    id: membershipId,
                    address: memberAddress,
                    keys: yield service.prepareMemberKeys(member.publicKey),
                    encPublicSigningKey: yield service.processWriteString(member.publicSigningKey),
                    memberDetails: yield service.processMemberDetails({ name: (_a = member.options) === null || _a === void 0 ? void 0 : _a.name }, service.vault.cacheOnly),
                };
                const data = yield service.uploadState(state);
                dataArray.push({
                    id: membershipId,
                    data
                });
                membersMetadata.push({
                    address: memberAddress,
                    publicKey: member.publicKey,
                    publicSigningKey: member.publicSigningKey,
                    expirationDate: (_b = member.options) === null || _b === void 0 ? void 0 : _b.expirationDate
                });
                memberArray.push({ address: memberAddress, id: membershipId, role: member.role, data });
                memberTags.push(new contract_1.Tag(constants_1.protocolTags.MEMBER_ADDRESS, memberAddress));
                memberTags.push(new contract_1.Tag(constants_1.protocolTags.MEMBERSHIP_ID, membershipId));
            }
            service.arweaveTags = memberTags.concat(yield service.getTxTags());
            const input = {
                function: service.function,
                members: memberArray
            };
            const { id } = yield this.api.postContractTransaction(service.vaultId, input, service.arweaveTags, { members: membersMetadata });
            return { members: input.members, transactionId: id };
        });
    }
    /**
     * @param  {string} membershipId
     * @returns Promise with corresponding transaction id
     */
    accept(membershipId) {
        return __awaiter(this, void 0, void 0, function* () {
            const profileService = new profile_1.ProfileService(this.wallet, this.api);
            const memberDetails = yield profileService.get();
            const service = new MembershipService(this.wallet, this.api);
            yield service.setVaultContextFromMembershipId(membershipId);
            const state = {
                memberDetails: yield service.processMemberDetails(memberDetails, service.object.__cacheOnly__),
                encPublicSigningKey: yield service.processWriteString(this.wallet.signingPublicKey())
            };
            service.setActionRef(constants_1.actionRefs.MEMBERSHIP_ACCEPT);
            service.setFunction(constants_1.functions.MEMBERSHIP_ACCEPT);
            const data = yield service.mergeAndUploadState(state);
            const { id, object } = yield this.api.postContractTransaction(service.vaultId, { function: service.function, data }, yield service.getTxTags());
            const membership = yield this.processMembership(object, !service.isPublic, service.keys);
            return { transactionId: id, object: membership };
        });
    }
    /**
     * @param  {string} membershipId
     * @returns Promise with corresponding transaction id
     */
    confirm(membershipId) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = new MembershipService(this.wallet, this.api);
            yield service.setVaultContextFromMembershipId(membershipId);
            service.setActionRef(constants_1.actionRefs.MEMBERSHIP_CONFIRM);
            service.setFunction(constants_1.functions.MEMBERSHIP_INVITE);
            const { address, publicKey, publicSigningKey } = yield this.api.getUserPublicData(service.object.email);
            const state = {
                keys: yield service.prepareMemberKeys(publicKey),
                encPublicSigningKey: yield service.processWriteString(publicSigningKey)
            };
            service.arweaveTags = [new contract_1.Tag(constants_1.protocolTags.MEMBER_ADDRESS, address)]
                .concat(yield service.getTxTags());
            const dataTxId = yield service.uploadState(state);
            const input = {
                function: service.function,
                address,
                data: dataTxId,
                role: service.object.role
            };
            const { id, object } = yield this.api.postContractTransaction(service.vaultId, input, service.arweaveTags);
            const membership = yield this.processMembership(object, !service.isPublic, service.keys);
            return { transactionId: id, object: membership };
        });
    }
    /**
     * @param  {string} membershipId
     * @returns Promise with corresponding transaction id
     */
    reject(membershipId) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = new MembershipService(this.wallet, this.api);
            yield service.setVaultContextFromMembershipId(membershipId);
            service.setActionRef(constants_1.actionRefs.MEMBERSHIP_REJECT);
            service.setFunction(constants_1.functions.MEMBERSHIP_REJECT);
            const { id, object } = yield this.api.postContractTransaction(service.vaultId, { function: service.function }, yield service.getTxTags());
            const membership = yield this.processMembership(object, !service.isPublic, service.keys);
            return { transactionId: id, object: membership };
        });
    }
    /**
     * @param  {string} membershipId
     * @returns Promise with corresponding transaction id
     */
    leave(membershipId) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = new MembershipService(this.wallet, this.api);
            yield service.setVaultContextFromMembershipId(membershipId);
            service.setActionRef(constants_1.actionRefs.MEMBERSHIP_LEAVE);
            service.setFunction(constants_1.functions.MEMBERSHIP_REJECT);
            const { id, object } = yield this.api.postContractTransaction(service.vaultId, { function: service.function }, yield service.getTxTags());
            const membership = yield this.processMembership(object, !service.isPublic, service.keys);
            return { transactionId: id, object: membership };
        });
    }
    /**
     * @param  {string} membershipId
     * @returns Promise with corresponding transaction id
     */
    revoke(membershipId) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = new MembershipService(this.wallet, this.api);
            yield service.setVaultContextFromMembershipId(membershipId);
            service.setActionRef(constants_1.actionRefs.MEMBERSHIP_REVOKE);
            service.setFunction(constants_1.functions.MEMBERSHIP_REVOKE);
            service.arweaveTags = yield service.getTxTags();
            let data;
            if (!service.isPublic) {
                const memberships = yield this.listAll(service.vaultId, { shouldDecrypt: false });
                const activeMembers = memberships.filter((member) => member.id !== service.objectId
                    && (member.status === constants_1.status.ACCEPTED || member.status === constants_1.status.PENDING));
                // rotate keys for all active members
                const memberPublicKeys = new Map();
                yield Promise.all(activeMembers.map((member) => __awaiter(this, void 0, void 0, function* () {
                    const { publicKey } = yield this.api.getUserPublicData(member.email);
                    memberPublicKeys.set(member.id, publicKey);
                })));
                const { memberKeys } = yield service.rotateMemberKeys(memberPublicKeys);
                // upload new state for all active members
                data = [];
                yield Promise.all(activeMembers.map((member) => __awaiter(this, void 0, void 0, function* () {
                    const memberService = new MembershipService(this.wallet, this.api);
                    memberService.setVaultId(service.vaultId);
                    memberService.setObjectId(member.id);
                    memberService.setObject(member);
                    const dataTx = yield memberService.mergeAndUploadState({ keys: memberKeys.get(member.id) });
                    data.push({ id: member.id, value: dataTx });
                })));
            }
            const { id, object } = yield this.api.postContractTransaction(service.vaultId, { function: service.function, data }, service.arweaveTags);
            const membership = yield this.processMembership(object, !service.isPublic, service.keys);
            return { transactionId: id, object: membership };
        });
    }
    /**
     * @param  {string} membershipId
     * @param  {RoleType} role VIEWER/CONTRIBUTOR/OWNER
     * @returns Promise with corresponding transaction id
     */
    changeRole(membershipId, role) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = new MembershipService(this.wallet, this.api);
            yield service.setVaultContextFromMembershipId(membershipId);
            service.setActionRef(constants_1.actionRefs.MEMBERSHIP_CHANGE_ROLE);
            service.setFunction(constants_1.functions.MEMBERSHIP_CHANGE_ROLE);
            const { id, object } = yield this.api.postContractTransaction(service.vaultId, { function: service.function, role }, yield service.getTxTags());
            const membership = yield this.processMembership(object, !service.isPublic, service.keys);
            return { transactionId: id, object: membership };
        });
    }
    /**
     * Invite user without an Akord account
     * @param  {string} vaultId
     * @param  {string} email invitee's email
     * @param  {string} role CONTRIBUTOR or VIEWER
     * @param  {MembershipCreateOptions} [options] invitation email message, etc.
     * @returns Promise with new membership id & corresponding transaction id
     */
    inviteNewUser(vaultId, email, role, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { id } = yield this.api.inviteNewUser(vaultId, email, role, options.message);
            return { membershipId: id };
        });
    }
    /**
   * Revoke invite for user without an Akord account
   * @param  {string} vaultId
   * @param  {string} membershipId
   */
    revokeInvite(vaultId, membershipId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.api.revokeInvite(vaultId, membershipId);
        });
    }
    /**
     * @param  {string} membershipId
     * @returns Promise with corresponding transaction id
     */
    inviteResend(membershipId) {
        return __awaiter(this, void 0, void 0, function* () {
            const membership = yield this.api.getMembership(membershipId);
            if (membership.status !== constants_1.status.PENDING && membership.status !== constants_1.status.INVITED) {
                throw new bad_request_1.BadRequest("Cannot resend the invitation for member: " + membershipId +
                    ". Found invalid status: " + membership.status);
            }
            yield this.api.inviteResend(membership.vaultId, membershipId);
        });
    }
    profileUpdate(membershipId, name, avatar) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = new MembershipService(this.wallet, this.api);
            yield service.setVaultContextFromMembershipId(membershipId);
            const memberDetails = yield service.processMemberDetails({ name, avatar }, service.object.__cacheOnly__);
            service.setActionRef(constants_1.actionRefs.MEMBERSHIP_PROFILE_UPDATE);
            service.setFunction(constants_1.functions.MEMBERSHIP_UPDATE);
            const data = yield service.mergeAndUploadState({ memberDetails });
            const { id, object } = yield this.api.postContractTransaction(service.vaultId, { function: service.function, data }, yield service.getTxTags());
            const membership = yield this.processMembership(object, !service.isPublic, service.keys);
            return { transactionId: id, object: membership };
        });
    }
    setVaultContextFromMembershipId(membershipId, vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            const membership = yield this.api.getMembership(membershipId, vaultId);
            this.setVaultId(membership.vaultId);
            this.setIsPublic(membership.__public__);
            yield this.setMembershipKeys(membership);
            this.setObject(membership);
            this.setObjectId(membershipId);
            this.setObjectType(this.objectType);
        });
    }
    getTxTags() {
        const _super = Object.create(null, {
            getTxTags: { get: () => super.getTxTags }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const tags = yield _super.getTxTags.call(this);
            return tags.concat(new contract_1.Tag(constants_1.protocolTags.MEMBERSHIP_ID, this.objectId));
        });
    }
    processMembership(object, shouldDecrypt, keys) {
        return __awaiter(this, void 0, void 0, function* () {
            const membership = new membership_1.Membership(object, keys);
            if (shouldDecrypt) {
                try {
                    yield membership.decrypt();
                }
                catch (error) {
                    throw new incorrect_encryption_key_1.IncorrectEncryptionKey(error);
                }
            }
            return membership;
        });
    }
    prepareMemberKeys(publicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isPublic) {
                const keysEncrypter = new crypto_1.Encrypter(this.wallet, this.dataEncrypter.keys, (0, crypto_1.base64ToArray)(publicKey));
                try {
                    const keys = yield keysEncrypter.encryptMemberKeys([]);
                    return keys.map((keyPair) => {
                        delete keyPair.publicKey;
                        return keyPair;
                    });
                }
                catch (error) {
                    throw new incorrect_encryption_key_1.IncorrectEncryptionKey(error);
                }
            }
            else {
                return null;
            }
        });
    }
    rotateMemberKeys(publicKeys) {
        return __awaiter(this, void 0, void 0, function* () {
            const memberKeys = new Map();
            // generate a new vault key pair
            const keyPair = yield (0, crypto_1.generateKeyPair)();
            for (let [memberId, publicKey] of publicKeys) {
                const memberKeysEncrypter = new crypto_1.Encrypter(this.wallet, this.dataEncrypter.keys, (0, crypto_1.base64ToArray)(publicKey));
                try {
                    memberKeys.set(memberId, [yield memberKeysEncrypter.encryptMemberKey(keyPair)]);
                }
                catch (error) {
                    throw new incorrect_encryption_key_1.IncorrectEncryptionKey(error);
                }
            }
            return { memberKeys, keyPair };
        });
    }
    processMemberDetails(memberDetails, cacheOnly) {
        return __awaiter(this, void 0, void 0, function* () {
            const processedMemberDetails = {};
            if (!this.isPublic) {
                if (memberDetails.name) {
                    processedMemberDetails.name = yield this.processWriteString(memberDetails.name);
                }
                if (memberDetails.avatar) {
                    const { resourceUrl, resourceTx } = yield this.processAvatar(memberDetails.avatar, cacheOnly);
                    processedMemberDetails.avatarUri = [`arweave:${resourceTx}`, `s3:${resourceUrl}`];
                }
            }
            return new profile_details_1.ProfileDetails(processedMemberDetails);
        });
    }
    processAvatar(avatar, cacheOnly) {
        return __awaiter(this, void 0, void 0, function* () {
            const { processedData, encryptionTags } = yield this.processWriteRaw(avatar);
            return this.api.uploadFile(processedData, encryptionTags, { cacheOnly, public: false });
        });
    }
}
exports.MembershipService = MembershipService;
;
