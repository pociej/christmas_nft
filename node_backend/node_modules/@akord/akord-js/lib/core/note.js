"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoteService = void 0;
const node_1 = require("./node");
const node_2 = require("../types/node");
const stack_1 = require("./stack");
const crypto_1 = require("@akord/crypto");
class NoteService extends node_1.NodeService {
    constructor() {
        super(...arguments);
        this.stackService = new stack_1.StackService(this.wallet, this.api);
        this.objectType = node_2.nodeType.STACK;
        this.NodeType = node_2.Stack;
        this.defaultCreateOptions = {
            parentId: undefined,
            mimeType: NoteTypes.MD
        };
    }
    /**
     * Get note version by index, return the latest version by default
     * @param  {string} noteId
     * @param  {number} [index] note version index
     * @returns Promise with version name & data string
     */
    getVersion(noteId, index) {
        return __awaiter(this, void 0, void 0, function* () {
            const version = yield this.stackService.getVersion(noteId, index);
            return { data: (0, crypto_1.arrayToString)(version.data), name: version.name };
        });
    }
    /**
     * @param  {string} vaultId
     * @returns Promise with all notes within given vault
     */
    list(vaultId, options = this.defaultListOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const stacks = yield this.stackService.list(vaultId, options);
            const notes = stacks.items.filter((stack) => this.isValidNoteType(stack.getVersion().type));
            return { items: notes, nextToken: stacks.nextToken };
        });
    }
    /**
     * @param  {string} vaultId
     * @param  {string} content note content, ex: stringified JSON
     * @param  {string} name note name
     * @param  {NoteCreateOptions} [options] parent id, mime type, etc.
     * @returns Promise with new note id & corresponding transaction id
     */
    create(vaultId, content, name, options = this.defaultCreateOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const createOptions = Object.assign(Object.assign({}, this.defaultCreateOptions), options);
            const { stackId, transactionId, object } = yield this.stackService.create(vaultId, [content], name, Object.assign(Object.assign({}, createOptions), { name }));
            return { noteId: stackId, transactionId, object };
        });
    }
    /**
     * @param  {string} noteId
     * @param  {string} content note content, ex: stringified JSON
     * @param  {string} name note name
     * @param  {NoteOptions} [options] parent id, mime type, etc.
     * @returns Promise with corresponding transaction id
     */
    uploadRevision(noteId, content, name, options = this.defaultCreateOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.stackService.uploadRevision(noteId, [content], { name, mimeType: options.mimeType });
        });
    }
    isValidNoteType(type) {
        return Object.values(NoteTypes).includes(type);
    }
}
exports.NoteService = NoteService;
;
var NoteTypes;
(function (NoteTypes) {
    NoteTypes["MD"] = "text/markdown";
    NoteTypes["JSON"] = "application/json";
})(NoteTypes || (NoteTypes = {}));
