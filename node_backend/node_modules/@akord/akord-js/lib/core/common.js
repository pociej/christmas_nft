"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEncryptedPayload = exports.mergeState = exports.paginate = exports.handleListErrors = void 0;
const lodash_1 = __importDefault(require("lodash"));
const crypto_1 = require("@akord/crypto");
const handleListErrors = (originalItems, promises) => __awaiter(void 0, void 0, void 0, function* () {
    const results = yield Promise.all(promises.map(p => p.catch(e => e)));
    const items = results.filter(result => !(result instanceof Error));
    const errors = results
        .map((result, index) => ({ result, index }))
        .filter((mapped) => mapped.result instanceof Error)
        .map((filtered) => ({ id: originalItems[filtered.index].id, error: filtered.result }));
    return { items, errors };
});
exports.handleListErrors = handleListErrors;
const paginate = (apiCall, listOptions) => __awaiter(void 0, void 0, void 0, function* () {
    let token = undefined;
    let results = [];
    do {
        const { items, nextToken } = yield apiCall(listOptions);
        results = results.concat(items);
        token = nextToken;
        listOptions.nextToken = nextToken;
        if (nextToken === "null") {
            token = undefined;
        }
    } while (token);
    return results;
});
exports.paginate = paginate;
const mergeState = (currentState, stateUpdates) => {
    let newState = lodash_1.default.cloneDeepWith(currentState);
    lodash_1.default.mergeWith(newState, stateUpdates, function concatArrays(objValue, srcValue) {
        if (lodash_1.default.isArray(objValue)) {
            return objValue.concat(srcValue);
        }
    });
    return newState;
};
exports.mergeState = mergeState;
const getEncryptedPayload = (data, metadata) => {
    const { encryptedKey, iv } = metadata;
    if (encryptedKey && iv) {
        return {
            encryptedKey,
            encryptedData: {
                iv: (0, crypto_1.base64ToArray)(iv),
                ciphertext: data
            }
        };
    }
    return null;
};
exports.getEncryptedPayload = getEncryptedPayload;
