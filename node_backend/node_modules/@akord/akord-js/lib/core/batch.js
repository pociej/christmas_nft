"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BatchService = void 0;
const core_1 = require("../core");
const uuid_1 = require("uuid");
const membership_1 = require("./membership");
const stack_1 = require("./stack");
const file_1 = require("./file");
const constants_1 = require("../constants");
const contract_1 = require("../types/contract");
const node_1 = require("./node");
const bad_request_1 = require("../errors/bad-request");
function* chunks(arr, n) {
    for (let i = 0; i < arr.length; i += n) {
        yield arr.slice(i, i + n);
    }
}
class BatchService extends core_1.Service {
    /**
     * @param  {{id:string,type:NoteType}[]} items
     * @returns Promise with corresponding transaction ids
     */
    revoke(items) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.batchUpdate(items.map((item) => (Object.assign(Object.assign({}, item), { input: { function: constants_1.functions.NODE_REVOKE }, actionRef: item.type.toUpperCase() + "_REVOKE" }))));
        });
    }
    /**
     * @param  {{id:string,type:NoteType}[]} items
     * @returns Promise with corresponding transaction ids
     */
    restore(items) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.batchUpdate(items.map((item) => (Object.assign(Object.assign({}, item), { input: { function: constants_1.functions.NODE_RESTORE }, actionRef: item.type.toUpperCase() + "_RESTORE" }))));
        });
    }
    /**
     * @param  {{id:string,type:NodeType}[]} items
     * @returns Promise with corresponding transaction ids
     */
    delete(items) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.batchUpdate(items.map((item) => (Object.assign(Object.assign({}, item), { input: { function: constants_1.functions.NODE_DELETE }, actionRef: item.type.toUpperCase() + "_DELETE" }))));
        });
    }
    /**
     * @param  {{id:string,type:NodeType}[]} items
     * @returns Promise with corresponding transaction ids
     */
    move(items, parentId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.batchUpdate(items.map((item) => (Object.assign(Object.assign({}, item), { input: {
                    function: constants_1.functions.NODE_MOVE,
                    parentId: parentId
                }, actionRef: item.type.toUpperCase() + "_MOVE" }))));
        });
    }
    /**
     * @param  {{id:string,role:RoleType}[]} items
     * @returns Promise with corresponding transaction ids
     */
    membershipChangeRole(items) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.batchUpdate(items.map((item) => ({
                id: item.id,
                type: constants_1.objectType.MEMBERSHIP,
                input: {
                    function: constants_1.functions.MEMBERSHIP_CHANGE_ROLE,
                    role: item.role
                },
                actionRef: constants_1.actionRefs.MEMBERSHIP_CHANGE_ROLE
            })));
        });
    }
    /**
     * @param  {string} vaultId
     * @param  {{file:FileLike,name:string,options:StackCreateOptions}[]} items
     * @param  {BatchStackCreateOptions} [options]
     * @returns Promise with new stack ids & their corresponding transaction ids
     */
    stackCreate(vaultId, items, options = {}) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const size = items.reduce((sum, stack) => {
                return sum + stack.file.size;
            }, 0);
            let progress = 0;
            let processedStacksCount = 0;
            const perFileProgress = new Map();
            if (options.processingCountHook) {
                options.processingCountHook(processedStacksCount);
            }
            let data = [];
            const errors = [];
            const transactions = [];
            if (options.progressHook) {
                const onProgress = options.progressHook;
                const stackProgressHook = (localProgress, data) => {
                    const stackBytesUploaded = Math.floor(localProgress / 100 * data.total);
                    progress += stackBytesUploaded - (perFileProgress.get(data.id) || 0);
                    perFileProgress.set(data.id, stackBytesUploaded);
                    onProgress(Math.min(100, Math.round(progress / size * 100)));
                };
                options.progressHook = stackProgressHook;
            }
            // set service context
            const vault = yield this.api.getVault(vaultId);
            this.setVault(vault);
            this.setVaultId(vaultId);
            this.setIsPublic(vault.public);
            yield this.setMembershipKeys(vault);
            this.setGroupRef(items);
            this.setActionRef(constants_1.actionRefs.STACK_CREATE);
            this.setFunction(constants_1.functions.NODE_CREATE);
            const stackCreateOptions = Object.assign(Object.assign({}, options), { cacheOnly: this.vault.cacheOnly });
            for (const chunk of [...chunks(items, BatchService.BATCH_CHUNK_SIZE)]) {
                // upload file data & metadata
                Promise.all(chunk.map((item) => __awaiter(this, void 0, void 0, function* () {
                    const service = new stack_1.StackService(this.wallet, this.api, this);
                    const nodeId = (0, uuid_1.v4)();
                    service.setObjectId(nodeId);
                    const createOptions = Object.assign(Object.assign({}, stackCreateOptions), (item.options || {}));
                    service.setAkordTags((service.isPublic ? [item.name] : []).concat(createOptions.tags));
                    service.setParentId(createOptions.parentId);
                    service.arweaveTags = yield service.getTxTags();
                    const fileService = new file_1.FileService(this.wallet, this.api, service);
                    const fileUploadResult = yield fileService.create(item.file, createOptions);
                    const version = yield fileService.newVersion(item.file, fileUploadResult);
                    const state = {
                        name: yield service.processWriteString(item.name ? item.name : item.file.name),
                        versions: [version],
                        tags: service.tags
                    };
                    const id = yield service.uploadState(state);
                    processedStacksCount += 1;
                    if (options.processingCountHook) {
                        options.processingCountHook(processedStacksCount);
                    }
                    // queue the stack transaction for posting
                    transactions.push({
                        vaultId: service.vaultId,
                        input: { function: service.function, data: id, parentId: createOptions.parentId },
                        tags: service.arweaveTags,
                        item
                    });
                })));
            }
            // post queued stack transactions
            let currentTx;
            let stacksCreated = 0;
            while (stacksCreated < items.length) {
                if ((_a = options.cancelHook) === null || _a === void 0 ? void 0 : _a.signal.aborted) {
                    return { data, errors, cancelled: items.length - stacksCreated };
                }
                if (transactions.length === 0) {
                    // wait for a while if the queue is empty before checking again
                    yield new Promise((resolve) => setTimeout(resolve, BatchService.TRANSACTION_QUEUE_WAIT_TIME));
                }
                else {
                    try {
                        currentTx = transactions.shift();
                        // process the dequeued stack transaction
                        const { id, object } = yield this.api.postContractTransaction(currentTx.vaultId, currentTx.input, currentTx.tags);
                        if (options.onStackCreated) {
                            yield options.onStackCreated(object);
                        }
                        const stack = yield new stack_1.StackService(this.wallet, this.api, this)
                            .processNode(object, !this.isPublic, this.keys);
                        data.push({ transactionId: id, object: stack, stackId: object.id });
                        stacksCreated += 1;
                        if ((_b = options.cancelHook) === null || _b === void 0 ? void 0 : _b.signal.aborted) {
                            return { data, errors, cancelled: items.length - stacksCreated };
                        }
                    }
                    catch (error) {
                        errors.push({ name: currentTx.item.name, message: error.toString(), error });
                    }
                    ;
                }
            }
            if ((_c = options.cancelHook) === null || _c === void 0 ? void 0 : _c.signal.aborted) {
                return { data, errors, cancelled: items.length - stacksCreated };
            }
            return { data, errors, cancelled: 0 };
        });
    }
    /**
     * @param  {string} vaultId
     * @param  {{email:string,role:RoleType}[]} items
     * @param  {MembershipCreateOptions} [options] invitation email message, etc.
     * @returns Promise with new membership ids & their corresponding transaction ids
     */
    membershipInvite(vaultId, items, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const members = yield this.api.getMembers(vaultId);
            const data = [];
            const errors = [];
            const transactions = [];
            // set service context
            this.setGroupRef(items);
            const vault = yield this.api.getVault(vaultId);
            this.setVault(vault);
            this.setVaultId(vaultId);
            this.setIsPublic(vault.public);
            yield this.setMembershipKeys(vault);
            this.setActionRef(constants_1.actionRefs.MEMBERSHIP_INVITE);
            this.setFunction(constants_1.functions.MEMBERSHIP_INVITE);
            // upload metadata
            yield Promise.all(items.map((item) => __awaiter(this, void 0, void 0, function* () {
                const email = item.email.toLowerCase();
                const role = item.role;
                const member = members.find(item => { var _a; return ((_a = item.email) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === email; });
                if (member && membership_1.activeStatus.includes(member.status)) {
                    const message = "Membership already exists for this user.";
                    errors.push({ email: email, message, error: new bad_request_1.BadRequest(message) });
                }
                else {
                    const userHasAccount = yield this.api.existsUser(email);
                    const service = new membership_1.MembershipService(this.wallet, this.api, this);
                    if (userHasAccount) {
                        const membershipId = (0, uuid_1.v4)();
                        service.setObjectId(membershipId);
                        const { address, publicKey, publicSigningKey } = yield this.api.getUserPublicData(email);
                        const state = {
                            keys: yield service.prepareMemberKeys(publicKey),
                            encPublicSigningKey: yield service.processWriteString(publicSigningKey)
                        };
                        service.arweaveTags = [new contract_1.Tag(constants_1.protocolTags.MEMBER_ADDRESS, address)]
                            .concat(yield service.getTxTags());
                        const dataTxId = yield service.uploadState(state);
                        transactions.push({
                            vaultId,
                            input: { function: service.function, address, role, data: dataTxId },
                            tags: service.arweaveTags,
                            item: item
                        });
                    }
                    else {
                        try {
                            const { id } = yield this.api.inviteNewUser(vaultId, email, role, options.message);
                            data.push({
                                membershipId: id,
                                transactionId: null
                            });
                        }
                        catch (error) {
                            errors.push({
                                email: email,
                                error: error,
                                message: error.message,
                                item: item
                            });
                        }
                    }
                }
            })));
            for (let tx of transactions) {
                try {
                    const { id, object } = yield this.api.postContractTransaction(vaultId, tx.input, tx.tags);
                    const membership = yield new membership_1.MembershipService(this.wallet, this.api, this).processMembership(object, !this.isPublic, this.keys);
                    data.push({ membershipId: membership.id, transactionId: id, object: membership });
                }
                catch (error) {
                    errors.push({
                        email: tx.item.email,
                        error: error,
                        message: error.message,
                        item: tx.item
                    });
                }
            }
            return { data: data, errors: errors };
        });
    }
    batchUpdate(items) {
        return __awaiter(this, void 0, void 0, function* () {
            this.setGroupRef(items);
            const result = [];
            for (const [itemIndex, item] of items.entries()) {
                const node = item.type === constants_1.objectType.MEMBERSHIP
                    ? yield this.api.getMembership(item.id)
                    : yield this.api.getNode(item.id, item.type);
                if (itemIndex === 0 || this.vaultId !== node.vaultId) {
                    this.setVaultId(node.vaultId);
                    this.setIsPublic(node.__public__);
                    yield this.setMembershipKeys(node);
                }
                const service = item.type === constants_1.objectType.MEMBERSHIP
                    ? new membership_1.MembershipService(this.wallet, this.api, this)
                    : new node_1.NodeService(this.wallet, this.api, this);
                service.setFunction(item.input.function);
                service.setActionRef(item.actionRef);
                service.setObject(node);
                service.setObjectId(item.id);
                service.setObjectType(item.type);
                service.arweaveTags = yield service.getTxTags();
                const { id, object } = yield this.api.postContractTransaction(this.vaultId, item.input, service.arweaveTags);
                const processedObject = item.type === constants_1.objectType.MEMBERSHIP
                    ? yield service.processMembership(object, !this.isPublic, this.keys)
                    : yield service.processNode(object, !this.isPublic, this.keys);
                result.push({ transactionId: id, object: processedObject });
            }
            return result;
        });
    }
    setGroupRef(items) {
        this.groupRef = items && items.length > 1 ? (0, uuid_1.v4)() : null;
    }
}
exports.BatchService = BatchService;
BatchService.BATCH_CHUNK_SIZE = 50;
BatchService.TRANSACTION_QUEUE_WAIT_TIME = 1;
