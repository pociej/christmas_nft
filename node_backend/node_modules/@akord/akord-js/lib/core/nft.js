"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NFTService = exports.nftMetadataToTags = void 0;
const node_1 = require("./node");
const node_2 = require("../types/node");
const file_1 = require("./file");
const nft_1 = require("../types/nft");
const constants_1 = require("../constants");
const asset_1 = require("../types/asset");
const bad_request_1 = require("../errors/bad-request");
const DEFAULT_TICKER = "ATOMIC";
const DEFAULT_TYPE = "image";
const DEFAULT_CONTRACT_SRC = "Of9pi--Gj7hCTawhgxOwbuWnFI1h24TTgO5pw8ENJNQ"; // Atomic asset contract source
class NFTService extends node_1.NodeService {
    constructor() {
        super(...arguments);
        this.objectType = node_2.nodeType.NFT;
        this.NodeType = nft_1.NFT;
    }
    /**
     * @param  {string} vaultId
     * @param  {FileLike} asset
     * @param  {NFTMetadata} metadata
     * @param  {StackCreateOptions} options
     * @returns Promise with corresponding transaction id
     */
    mint(vaultId, asset, metadata, options = this.defaultCreateOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const vault = yield this.api.getVault(vaultId);
            if (!vault.public || vault.cacheOnly) {
                throw new bad_request_1.BadRequest("NFT module applies only to public permanent vaults.");
            }
            const nftTags = (0, exports.nftMetadataToTags)(metadata);
            const createOptions = Object.assign(Object.assign({}, this.defaultCreateOptions), options);
            const service = new NFTService(this.wallet, this.api);
            service.setVault(vault);
            service.setVaultId(vaultId);
            service.setIsPublic(vault.public);
            yield service.setMembershipKeys(vault);
            service.setActionRef(constants_1.actionRefs.NFT_MINT);
            service.setFunction(constants_1.functions.NODE_CREATE);
            service.setAkordTags([]);
            createOptions.arweaveTags = (createOptions.arweaveTags || [{ name: 'Content-Type', value: asset.type }]).concat(nftTags);
            createOptions.cacheOnly = service.vault.cacheOnly;
            if (createOptions.ucm) {
                createOptions.arweaveTags = createOptions.arweaveTags.concat([{ name: 'Indexed-By', value: 'ucm' }]);
            }
            const fileService = new file_1.FileService(this.wallet, this.api, service);
            const fileUploadResult = yield fileService.create(asset, createOptions);
            const version = yield fileService.newVersion(asset, fileUploadResult);
            const state = JSON.parse(nftTags.find((tag) => tag.name === "Init-State").value);
            state.asset = version;
            const { nodeId, transactionId, object } = yield service.nodeCreate(state, { parentId: options.parentId });
            return { nftId: nodeId, transactionId, object };
        });
    }
    /**
     * Get NFT asset
     * @param  {string} nftId
     * @returns Promise with NFT asset
     */
    getAsset(nftId) {
        return __awaiter(this, void 0, void 0, function* () {
            const nft = new nft_1.NFT(yield this.api.getNode(nftId, this.objectType));
            const { fileData } = yield this.api.downloadFile(nft.getUri(node_2.StorageType.S3), { public: true });
            return Object.assign({ data: fileData }, nft.asset);
        });
    }
    /**
     * Get NFT asset uri
     * @param  {string} nftId
     * @param  {StorageType} [type] storage type, default to arweave
     * @returns Promise with NFT asset uri
     */
    getUri(nftId, type = node_2.StorageType.ARWEAVE) {
        return __awaiter(this, void 0, void 0, function* () {
            const nft = new nft_1.NFT(yield this.api.getNode(nftId, this.objectType));
            return nft.getUri(type);
        });
    }
}
exports.NFTService = NFTService;
;
const nftMetadataToTags = (metadata) => {
    const initState = {
        ticker: metadata.ticker || DEFAULT_TICKER,
        name: metadata.name,
        description: metadata.description,
        creator: metadata.creator || metadata.owner,
        collection: metadata.collection,
        owner: metadata.owner,
        canEvolve: true,
        balances: {
            [metadata.owner]: 1,
        },
        claimable: []
    };
    const nftTags = [
        { name: constants_1.smartweaveTags.APP_NAME, value: 'SmartWeaveContract' },
        { name: constants_1.smartweaveTags.APP_VERSION, value: '0.3.0' },
        { name: constants_1.smartweaveTags.CONTRACT_SOURCE, value: metadata.contractTxId || DEFAULT_CONTRACT_SRC },
        { name: constants_1.smartweaveTags.INIT_STATE, value: JSON.stringify(initState) },
        { name: asset_1.assetTags.TITLE, value: metadata.name },
        { name: asset_1.assetTags.TYPE, value: metadata.type || DEFAULT_TYPE },
        { name: 'Contract-Manifest', value: '{"evaluationOptions":{"sourceType":"redstone-sequencer","allowBigInt":true,"internalWrites":true,"unsafeClient":"skip","useConstructor":true}}' },
    ];
    if (metadata.creator) {
        nftTags.push({ name: 'Creator', value: metadata.creator });
    }
    if (metadata.description) {
        nftTags.push({ name: asset_1.assetTags.DESCRIPTION, value: metadata.description });
    }
    if (metadata.collection) {
        nftTags.push({ name: 'Collection-Code', value: metadata.collection });
    }
    if (metadata.topics) {
        for (let topic of metadata.topics) {
            nftTags.push({ name: asset_1.assetTags.TOPIC + ":" + topic, value: topic });
        }
    }
    return nftTags;
};
exports.nftMetadataToTags = nftMetadataToTags;
