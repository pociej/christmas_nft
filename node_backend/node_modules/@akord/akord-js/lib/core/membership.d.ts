import { objectType } from "../constants";
import { EncryptedKeys, Keys } from "@akord/crypto";
import { Service } from "./service";
import { Membership, RoleType, StatusType } from "../types/membership";
import { GetOptions, ListOptions } from "../types/query-options";
import { Tags } from "../types/contract";
import { Paginated } from "../types/paginated";
import { ProfileDetails } from "../types/profile-details";
export declare const activeStatus: StatusType[];
declare class MembershipService extends Service {
    objectType: objectType;
    defaultListOptions: ListOptions;
    defaultGetOptions: GetOptions;
    /**
     * @param  {string} membershipId
     * @returns Promise with the decrypted membership
     */
    get(membershipId: string, options?: GetOptions): Promise<Membership>;
    /**
     * @param  {string} vaultId
     * @param  {ListOptions} options
     * @returns Promise with paginated memberships within given vault
     */
    list(vaultId: string, options?: ListOptions): Promise<Paginated<Membership>>;
    /**
     * @param  {string} vaultId
     * @param  {ListOptions} options
     * @returns Promise with all memberships within given vault
     */
    listAll(vaultId: string, options?: ListOptions): Promise<Array<Membership>>;
    /**
     * Invite user with an Akord account
     * @param  {string} vaultId
     * @param  {string} email invitee's email
     * @param  {RoleType} role VIEWER/CONTRIBUTOR/OWNER
     * @param  {MembershipCreateOptions} [options] invitation email message, etc.
     * @returns Promise with new membership id & corresponding transaction id
     */
    invite(vaultId: string, email: string, role: RoleType, options?: MembershipCreateOptions): Promise<MembershipCreateResult>;
    /**
     * Airdrop access to the vault directly through public keys
     * @param  {string} vaultId
     * @param  {{publicKey:string,publicSigningKey:string,role:RoleType}[]} members
     * @returns Promise with new memberships & corresponding transaction id
     */
    airdrop(vaultId: string, members: Array<{
        publicKey: string;
        publicSigningKey: string;
        role: RoleType;
        options?: {
            name?: string;
            expirationDate?: Date;
        };
    }>): Promise<{
        transactionId: string;
        members: Array<{
            id: string;
            address: string;
        }>;
    }>;
    /**
     * @param  {string} membershipId
     * @returns Promise with corresponding transaction id
     */
    accept(membershipId: string): Promise<MembershipUpdateResult>;
    /**
     * @param  {string} membershipId
     * @returns Promise with corresponding transaction id
     */
    confirm(membershipId: string): Promise<MembershipUpdateResult>;
    /**
     * @param  {string} membershipId
     * @returns Promise with corresponding transaction id
     */
    reject(membershipId: string): Promise<MembershipUpdateResult>;
    /**
     * @param  {string} membershipId
     * @returns Promise with corresponding transaction id
     */
    leave(membershipId: string): Promise<MembershipUpdateResult>;
    /**
     * @param  {string} membershipId
     * @returns Promise with corresponding transaction id
     */
    revoke(membershipId: string): Promise<MembershipUpdateResult>;
    /**
     * @param  {string} membershipId
     * @param  {RoleType} role VIEWER/CONTRIBUTOR/OWNER
     * @returns Promise with corresponding transaction id
     */
    changeRole(membershipId: string, role: RoleType): Promise<MembershipUpdateResult>;
    /**
     * Invite user without an Akord account
     * @param  {string} vaultId
     * @param  {string} email invitee's email
     * @param  {string} role CONTRIBUTOR or VIEWER
     * @param  {MembershipCreateOptions} [options] invitation email message, etc.
     * @returns Promise with new membership id & corresponding transaction id
     */
    inviteNewUser(vaultId: string, email: string, role: RoleType, options?: MembershipCreateOptions): Promise<{
        membershipId: string;
    }>;
    /**
   * Revoke invite for user without an Akord account
   * @param  {string} vaultId
   * @param  {string} membershipId
   */
    revokeInvite(vaultId: string, membershipId: string): Promise<void>;
    /**
     * @param  {string} membershipId
     * @returns Promise with corresponding transaction id
     */
    inviteResend(membershipId: string): Promise<void>;
    profileUpdate(membershipId: string, name: string, avatar: ArrayBuffer): Promise<MembershipUpdateResult>;
    protected setVaultContextFromMembershipId(membershipId: string, vaultId?: string): Promise<void>;
    getTxTags(): Promise<Tags>;
    processMembership(object: Membership, shouldDecrypt: boolean, keys?: EncryptedKeys[]): Promise<Membership>;
    prepareMemberKeys(publicKey: string): Promise<EncryptedKeys[]>;
    rotateMemberKeys(publicKeys: Map<string, string>): Promise<{
        memberKeys: Map<string, EncryptedKeys[]>;
        keyPair: Keys;
    }>;
    processMemberDetails(memberDetails: {
        name?: string;
        avatar?: ArrayBuffer;
    }, cacheOnly?: boolean): Promise<ProfileDetails>;
    private processAvatar;
}
export declare type MembershipCreateOptions = {
    message?: string;
};
declare type MembershipCreateResult = {
    membershipId: string;
    transactionId: string;
    object: Membership;
};
declare type MembershipUpdateResult = {
    transactionId: string;
    object: Membership;
};
export { MembershipService };
