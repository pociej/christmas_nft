"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManifestService = exports.FILE_TYPE = exports.CONTENT_TYPE = void 0;
const node_1 = require("./node");
const node_2 = require("../types/node");
const stack_1 = require("./stack");
const folder_1 = require("./folder");
const crypto_1 = require("@akord/crypto");
const bad_request_1 = require("../errors/bad-request");
exports.CONTENT_TYPE = "application/x.arweave-manifest+json";
exports.FILE_TYPE = "application/json";
const FILE_NAME = "manifest.json";
const MANIFEST_TYPE = "arweave/paths";
const MANIFEST_VERSION = "0.1.0";
class ManifestService extends node_1.NodeService {
    constructor() {
        super(...arguments);
        this.stackService = new stack_1.StackService(this.wallet, this.api);
        this.folderService = new folder_1.FolderService(this.wallet, this.api);
        this.objectType = node_2.nodeType.STACK;
        this.NodeType = node_2.Stack;
    }
    /**
     * @returns Promise with vault manifest node
     */
    get(vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            const stacks = yield this.stackService.listAll(vaultId);
            const manifest = stacks.find((stack) => stack.name === FILE_NAME);
            return manifest;
        });
    }
    /**
     * Get manifest version by index, return the latest version by default
     * @param  {string} vaultId
     * @param  {number} [index] manifest version index
     * @returns Promise with vault manifest JSON data
     */
    getVersion(vaultId, index) {
        return __awaiter(this, void 0, void 0, function* () {
            const manifest = yield this.get(vaultId);
            if (!manifest) {
                throw new bad_request_1.BadRequest("A vault manifest does not exist yet. Use akord.manifest.generate(vaultId) to create it.");
            }
            const manifestFile = yield this.stackService.getVersion(manifest.id, index);
            return JSON.parse((0, crypto_1.arrayToString)(manifestFile.data));
        });
    }
    /**
     * @param  {string} vaultId
     * @param  {JSON} manifest manifest JSON
     * @returns Promise with corresponding transaction id
     */
    generate(vaultId, manifest) {
        return __awaiter(this, void 0, void 0, function* () {
            this.stackService.fileService.contentType = exports.CONTENT_TYPE;
            const vault = yield this.api.getVault(vaultId);
            if (!vault.public) {
                throw new bad_request_1.BadRequest("Manifest applies only to public vaults.");
            }
            if (!manifest) {
                manifest = yield this.renderManifestJSON(vaultId);
            }
            const manifestNode = yield this.get(vaultId);
            if (manifestNode) {
                // update vault manifest
                return yield this.stackService.uploadRevision(manifestNode.id, [JSON.stringify(manifest)], { name: FILE_NAME, mimeType: exports.FILE_TYPE });
            }
            else {
                // create new vault manifest
                return yield this.stackService.create(vaultId, [JSON.stringify(manifest)], FILE_NAME, { name: FILE_NAME, mimeType: exports.FILE_TYPE });
            }
        });
    }
    /**
     *
     * @returns manifest in json format
     */
    renderManifestJSON(vaultId, indexName) {
        return __awaiter(this, void 0, void 0, function* () {
            // takes a flat list of folders and stacks and generates a tree
            const treeify = (folders, stacks) => {
                // initalize our treelist with a root folder + stacks
                var treeList = [{ id: null, parentId: null, name: null, stacks: [] }];
                stacks.forEach((s) => {
                    if (!s["parentId"])
                        treeList[0]["stacks"].push(s);
                });
                // setup a lookup table
                var lookup = {};
                folders.forEach(function (obj) {
                    lookup[obj["id"]] = obj;
                    obj["children"] = [];
                    obj["stacks"] = [];
                    // add the related stacks to this folder
                    stacks.forEach((s) => {
                        if (s["parentId"] === obj["id"])
                            obj["stacks"].push(s);
                    });
                });
                // add the folders  to its parent folder (tree)
                folders.forEach((obj) => {
                    if (obj["parentId"] != null) {
                        lookup[obj["parentId"]]["children"].push(obj);
                    }
                    else {
                        treeList.push(obj);
                    }
                });
                return treeList;
            };
            // take the hierachical tree and compute the folder paths
            const computePaths = (tree, path) => {
                const paths = [];
                tree.forEach((folder) => {
                    folder['stacks'].forEach((stack) => {
                        // construct the path name
                        const pathName = [path, folder['name'], stack.name]
                            .filter((p) => p != null)
                            .join("/");
                        const arweaveId = stack.getUri();
                        paths.push({
                            id: arweaveId,
                            path: pathName,
                        });
                    });
                    // process the children
                    if (folder['children']) {
                        let pathName = folder['name'];
                        if (path)
                            pathName = [path, folder['name']].join("/");
                        const children = computePaths(folder['children'], pathName);
                        paths.push(...children);
                    }
                });
                return paths;
            };
            // load and clean list of folders
            const folders = (yield this.folderService.listAll(vaultId)).map((n) => {
                const { id, parentId, name } = n;
                return { id, parentId, name };
            });
            // load and clean list of stacks
            const stacks = (yield this.stackService.listAll(vaultId)).map((s) => {
                const { id, parentId, name, versions } = s;
                return new node_2.Stack({ id, parentId, name, versions }, null);
            });
            const tree = treeify(folders, stacks);
            const paths = computePaths(tree, null);
            // map paths to manifest hash
            const manifest = {};
            paths.forEach((path) => {
                manifest[path.path] = { id: path.id };
            });
            return {
                manifest: MANIFEST_TYPE,
                version: MANIFEST_VERSION,
                index: {
                    path: indexName || "index.html",
                },
                paths: manifest,
            };
        });
    }
    ;
}
exports.ManifestService = ManifestService;
;
