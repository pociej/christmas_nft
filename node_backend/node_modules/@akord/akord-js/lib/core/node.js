"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeService = void 0;
const service_1 = require("./service");
const constants_1 = require("../constants");
const node_1 = require("../types/node");
const contract_1 = require("../types/contract");
const uuid_1 = require("uuid");
const incorrect_encryption_key_1 = require("../errors/incorrect-encryption-key");
const bad_request_1 = require("../errors/bad-request");
const common_1 = require("./common");
const nft_1 = require("../types/nft");
class NodeService extends service_1.Service {
    constructor() {
        super(...arguments);
        this.defaultListOptions = {
            shouldDecrypt: true,
            parentId: undefined,
            filter: {
                status: { ne: constants_1.status.REVOKED },
                and: {
                    status: { ne: constants_1.status.DELETED }
                }
            }
        };
        this.defaultGetOptions = {
            shouldDecrypt: true,
        };
        this.defaultCreateOptions = {
            parentId: undefined,
            tags: [],
            arweaveTags: [],
        };
    }
    /**
     * @param  {string} nodeId
     * @returns Promise with the decrypted node
     */
    get(nodeId, options = this.defaultGetOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const getOptions = Object.assign(Object.assign({}, this.defaultGetOptions), options);
            const nodeProto = yield this.api.getNode(nodeId, this.objectType, getOptions.vaultId);
            const node = yield this.processNode(nodeProto, !nodeProto.__public__ && getOptions.shouldDecrypt, nodeProto.__keys__);
            return node;
        });
    }
    /**
     * @param  {string} vaultId
     * @param  {ListOptions} options
     * @returns Promise with paginated nodes within given vault
     */
    list(vaultId, options = this.defaultListOptions = this.defaultListOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const listOptions = Object.assign(Object.assign({}, this.defaultListOptions), options);
            const response = yield this.api.getNodesByVaultId(vaultId, this.objectType, listOptions);
            const promises = response.items
                .map((nodeProto) => __awaiter(this, void 0, void 0, function* () {
                return yield this.processNode(nodeProto, !nodeProto.__public__ && listOptions.shouldDecrypt, nodeProto.__keys__);
            }));
            const { items, errors } = yield (0, common_1.handleListErrors)(response.items, promises);
            return {
                items,
                nextToken: response.nextToken,
                errors
            };
        });
    }
    /**
     * @param  {string} vaultId
     * @param  {ListOptions} options
     * @returns Promise with all nodes within given vault
     */
    listAll(vaultId, options = this.defaultListOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const list = (options) => __awaiter(this, void 0, void 0, function* () {
                return yield this.list(options.vaultId, options);
            });
            return yield (0, common_1.paginate)(list, Object.assign(Object.assign({}, options), { vaultId }));
        });
    }
    /**
     * @param  {string} nodeId
     * @param  {string} name new name
     * @returns Promise with corresponding transaction id
     */
    rename(nodeId, name) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = new NodeService(this.wallet, this.api);
            yield service.setVaultContextFromNodeId(nodeId, this.objectType);
            service.setActionRef(this.objectType.toUpperCase() + "_RENAME");
            service.setFunction(constants_1.functions.NODE_UPDATE);
            const state = {
                name: yield service.processWriteString(name)
            };
            return service.nodeUpdate(state);
        });
    }
    /**
     * @param  {string} nodeId
     * @param  {string} [parentId] new parent folder id
     * @returns Promise with corresponding transaction id
     */
    move(nodeId, parentId, vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = new NodeService(this.wallet, this.api);
            yield service.setVaultContextFromNodeId(nodeId, this.objectType, vaultId);
            service.setActionRef(this.objectType.toUpperCase() + "_MOVE");
            service.setFunction(constants_1.functions.NODE_MOVE);
            return service.nodeUpdate(null, { parentId });
        });
    }
    /**
     * @param  {string} nodeId
     * @returns Promise with corresponding transaction id
     */
    revoke(nodeId, vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = new NodeService(this.wallet, this.api);
            yield service.setVaultContextFromNodeId(nodeId, this.objectType, vaultId);
            service.setActionRef(this.objectType.toUpperCase() + "_REVOKE");
            service.setFunction(constants_1.functions.NODE_REVOKE);
            return service.nodeUpdate();
        });
    }
    /**
     * @param  {string} nodeId
     * @returns Promise with corresponding transaction id
     */
    restore(nodeId, vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = new NodeService(this.wallet, this.api);
            yield service.setVaultContextFromNodeId(nodeId, this.objectType, vaultId);
            service.setActionRef(this.objectType.toUpperCase() + "_RESTORE");
            service.setFunction(constants_1.functions.NODE_RESTORE);
            return service.nodeUpdate();
        });
    }
    /**
     * @param  {string} nodeId
     * @returns Promise with corresponding transaction id
     */
    delete(nodeId, vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = new NodeService(this.wallet, this.api);
            yield service.setVaultContextFromNodeId(nodeId, this.objectType, vaultId);
            service.setActionRef(this.objectType.toUpperCase() + "_DELETE");
            service.setFunction(constants_1.functions.NODE_DELETE);
            return service.nodeUpdate();
        });
    }
    nodeCreate(state, clientInput, clientTags) {
        return __awaiter(this, void 0, void 0, function* () {
            const nodeId = (0, uuid_1.v4)();
            this.setObjectId(nodeId);
            this.setFunction(constants_1.functions.NODE_CREATE);
            this.setFunction(constants_1.functions.NODE_CREATE);
            this.setParentId(clientInput.parentId);
            this.arweaveTags = yield this.getTxTags();
            clientTags === null || clientTags === void 0 ? void 0 : clientTags.map((tag) => this.arweaveTags.push(tag));
            const input = Object.assign({ function: this.function }, clientInput);
            if (state) {
                const id = yield this.uploadState(state);
                input.data = id;
            }
            const { id, object } = yield this.api.postContractTransaction(this.vaultId, input, this.arweaveTags);
            const node = yield this.processNode(object, !this.isPublic, this.keys);
            return { nodeId, transactionId: id, object: node };
        });
    }
    nodeUpdate(stateUpdates, clientInput) {
        return __awaiter(this, void 0, void 0, function* () {
            const input = Object.assign({ function: this.function }, clientInput);
            this.setParentId(clientInput === null || clientInput === void 0 ? void 0 : clientInput.parentId);
            this.arweaveTags = yield this.getTxTags();
            if (stateUpdates) {
                const id = yield this.mergeAndUploadState(stateUpdates);
                input.data = id;
            }
            const { id, object } = yield this.api.postContractTransaction(this.vaultId, input, this.arweaveTags);
            const node = yield this.processNode(object, !this.isPublic, this.keys);
            return { transactionId: id, object: node };
        });
    }
    setParentId(parentId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.parentId = parentId;
        });
    }
    setVaultContextFromNodeId(nodeId, type, vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            const object = yield this.api.getNode(nodeId, type, vaultId);
            this.setVaultId(object.vaultId);
            this.setIsPublic(object.__public__);
            yield this.setMembershipKeys(object);
            this.setObject(object);
            this.setObjectId(nodeId);
            this.setObjectType(type);
        });
    }
    getTxTags() {
        const _super = Object.create(null, {
            getTxTags: { get: () => super.getTxTags }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const tags = yield _super.getTxTags.call(this);
            tags.push(new contract_1.Tag(constants_1.protocolTags.NODE_ID, this.objectId));
            if (this.function === constants_1.functions.NODE_CREATE || this.function === constants_1.functions.NODE_MOVE) {
                tags.push(new contract_1.Tag(constants_1.protocolTags.PARENT_ID, this.parentId ? this.parentId : "root"));
            }
            return tags;
        });
    }
    processNode(object, shouldDecrypt, keys) {
        return __awaiter(this, void 0, void 0, function* () {
            const node = this.nodeInstance(object, keys);
            if (shouldDecrypt) {
                try {
                    yield node.decrypt();
                }
                catch (error) {
                    throw new incorrect_encryption_key_1.IncorrectEncryptionKey(error);
                }
            }
            return node;
        });
    }
    nodeInstance(nodeProto, keys) {
        // TODO: use a generic NodeLike constructor
        if (this.objectType === "Folder") {
            return new node_1.Folder(nodeProto, keys);
        }
        else if (this.objectType === "Stack") {
            return new node_1.Stack(nodeProto, keys);
        }
        else if (this.objectType === "Memo") {
            return new node_1.Memo(nodeProto, keys);
        }
        else if (this.objectType === "NFT") {
            return new nft_1.NFT(nodeProto);
        }
        else {
            throw new bad_request_1.BadRequest("Given type is not supported: " + this.objectType);
        }
    }
}
exports.NodeService = NodeService;
