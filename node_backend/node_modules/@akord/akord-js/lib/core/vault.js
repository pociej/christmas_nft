"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VaultService = void 0;
const constants_1 = require("../constants");
const uuid_1 = require("uuid");
const vault_1 = require("../types/vault");
const service_1 = require("./service");
const contract_1 = require("../types/contract");
const incorrect_encryption_key_1 = require("../errors/incorrect-encryption-key");
const membership_1 = require("./membership");
const lodash_1 = __importDefault(require("lodash"));
const not_found_1 = require("../errors/not-found");
const bad_request_1 = require("../errors/bad-request");
const common_1 = require("./common");
const profile_1 = require("./profile");
class VaultService extends service_1.Service {
    constructor() {
        super(...arguments);
        this.objectType = constants_1.objectType.VAULT;
        this.defaultListOptions = {
            shouldDecrypt: true,
            filter: { status: { eq: constants_1.status.ACCEPTED } }
        };
        this.defaultGetOptions = {
            shouldDecrypt: true,
            deep: false
        };
        this.defaultCreateOptions = {
            public: false,
            termsOfAccess: undefined,
            description: undefined,
            tags: [],
            cacheOnly: false,
            arweaveTags: [],
        };
    }
    /**
     * @param  {string} vaultId
     * @returns Promise with the decrypted vault
     */
    get(vaultId, options = this.defaultGetOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const getOptions = Object.assign(Object.assign({}, this.defaultGetOptions), options);
            const result = yield this.api.getVault(vaultId, getOptions);
            return yield this.processVault(result, !result.public && getOptions.shouldDecrypt, result.__keys__);
        });
    }
    /**
     * @param  {ListOptions} options
     * @returns Promise with paginated user vaults
     */
    list(options = this.defaultListOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const listOptions = Object.assign(Object.assign({}, this.defaultListOptions), options);
            const response = yield this.api.getVaults(listOptions);
            const promises = response.items
                .map((vaultProto) => __awaiter(this, void 0, void 0, function* () {
                return yield this.processVault(vaultProto, listOptions.shouldDecrypt, vaultProto.keys);
            }));
            const { items, errors } = yield (0, common_1.handleListErrors)(response.items, promises);
            return {
                items,
                nextToken: response.nextToken,
                errors
            };
        });
    }
    /**
     * @param  {ListOptions} options
     * @returns Promise with currently authenticated user vaults
     */
    listAll(options = this.defaultListOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const list = (listOptions) => __awaiter(this, void 0, void 0, function* () {
                return yield this.list(listOptions);
            });
            return yield (0, common_1.paginate)(list, options);
        });
    }
    /**
     * @param  {string} name new vault name
     * @param  {VaultCreateOptions} options public/private, terms of access, etc.
     * @returns Promise with new vault id, owner membership id & corresponding transaction id
     */
    create(name, options = this.defaultCreateOptions) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const createOptions = Object.assign(Object.assign({}, this.defaultCreateOptions), options);
            let vaultId;
            if (createOptions.cacheOnly) {
                vaultId = (0, uuid_1.v4)();
            }
            else {
                vaultId = yield this.api.initContractId([new contract_1.Tag(constants_1.protocolTags.NODE_TYPE, constants_1.objectType.VAULT)]);
            }
            const profileService = new profile_1.ProfileService(this.wallet, this.api);
            const memberDetails = yield profileService.get();
            const service = new VaultService(this.wallet, this.api);
            service.setActionRef(constants_1.actionRefs.VAULT_CREATE);
            service.setIsPublic(createOptions.public);
            service.setFunction(constants_1.functions.VAULT_CREATE);
            service.setVaultId(vaultId);
            service.setObjectId(vaultId);
            service.setAkordTags((service.isPublic ? [name] : []).concat(createOptions.tags));
            const address = yield this.wallet.getAddress();
            const membershipId = (0, uuid_1.v4)();
            service.arweaveTags = [
                new contract_1.Tag(constants_1.protocolTags.MEMBER_ADDRESS, address),
                new contract_1.Tag(constants_1.protocolTags.MEMBERSHIP_ID, membershipId),
            ].concat(yield service.getTxTags());
            (_a = createOptions.arweaveTags) === null || _a === void 0 ? void 0 : _a.map((tag) => service.arweaveTags.push(tag));
            const memberService = new membership_1.MembershipService(this.wallet, this.api, service);
            memberService.setVaultId(service.vaultId);
            memberService.setObjectId(membershipId);
            let keys;
            if (!service.isPublic) {
                const { memberKeys, keyPair } = yield memberService.rotateMemberKeys(new Map([[membershipId, this.wallet.publicKey()]]));
                keys = memberKeys.get(membershipId);
                service.setRawDataEncryptionPublicKey(keyPair.publicKey);
                service.setKeys([{ encPublicKey: keys[0].encPublicKey, encPrivateKey: keys[0].encPrivateKey }]);
                memberService.setRawDataEncryptionPublicKey(keyPair.publicKey);
                memberService.setKeys([{ encPublicKey: keys[0].encPublicKey, encPrivateKey: keys[0].encPrivateKey }]);
            }
            const vaultState = {
                name: yield service.processWriteString(name),
                termsOfAccess: createOptions.termsOfAccess,
                description: createOptions.description ? yield service.processWriteString(createOptions.description) : undefined,
                tags: createOptions.tags || []
            };
            const vaultStateTx = yield service.uploadState(vaultState, createOptions.cacheOnly);
            const memberState = {
                keys,
                encPublicSigningKey: yield memberService.processWriteString(this.wallet.signingPublicKey()),
                memberDetails: yield memberService.processMemberDetails(memberDetails, createOptions.cacheOnly)
            };
            const memberStateTx = yield memberService.uploadState(memberState, createOptions.cacheOnly);
            const data = { vault: vaultStateTx, membership: memberStateTx };
            const { id, object } = yield this.api.postContractTransaction(service.vaultId, { function: service.function, data }, service.arweaveTags, { cacheOnly: createOptions.cacheOnly });
            const vault = yield service.processVault(object, true, service.keys);
            return { vaultId, membershipId, transactionId: id, object: vault };
        });
    }
    /**
     * @param  {string} vaultId
     * @param  {VaultUpdateOptions} options name, description & tags
     * @returns Promise with corresponding transaction id
     */
    update(vaultId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!options.name && !options.tags && !options.description) {
                throw new bad_request_1.BadRequest("Nothing to update");
            }
            const service = new VaultService(this.wallet, this.api);
            yield service.setVaultContext(vaultId);
            service.setActionRef(constants_1.actionRefs.VAULT_UPDATE_METADATA);
            service.setFunction(constants_1.functions.VAULT_UPDATE);
            const currentState = yield service.getCurrentState();
            const newState = lodash_1.default.cloneDeepWith(currentState);
            if (options.name) {
                newState.name = yield service.processWriteString(options.name);
            }
            if (options.tags) {
                newState.tags = options.tags;
            }
            if (options.description) {
                newState.description = yield service.processWriteString(options.description);
            }
            service.setAkordTags((options.name && service.isPublic ? [options.name] : []).concat(options.tags));
            service.arweaveTags = yield service.getTxTags();
            const dataTxId = yield service.uploadState(newState);
            const { id, object } = yield this.api.postContractTransaction(service.vaultId, { function: service.function, data: dataTxId }, service.arweaveTags);
            const vault = yield this.processVault(object, true, service.keys);
            return { transactionId: id, object: vault };
        });
    }
    /**
     * @param vaultId
     * @param name new vault name
     * @returns Promise with corresponding transaction id
     */
    rename(vaultId, name) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = new VaultService(this.wallet, this.api);
            yield service.setVaultContext(vaultId);
            service.setActionRef(constants_1.actionRefs.VAULT_RENAME);
            service.setFunction(constants_1.functions.VAULT_UPDATE);
            const state = {
                name: yield service.processWriteString(name)
            };
            const data = yield service.mergeAndUploadState(state);
            service.setAkordTags(service.isPublic ? [name] : []);
            service.arweaveTags = yield service.getTxTags();
            const { id, object } = yield this.api.postContractTransaction(service.vaultId, { function: service.function, data }, service.arweaveTags);
            const vault = yield this.processVault(object, true, service.keys);
            return { transactionId: id, object: vault };
        });
    }
    /**
     * @param vaultId
     * @param tags tags to be added
     * @returns Promise with corresponding transaction id
     */
    addTags(vaultId, tags) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = new VaultService(this.wallet, this.api);
            yield service.setVaultContext(vaultId);
            service.setActionRef(constants_1.actionRefs.VAULT_ADD_TAGS);
            service.setFunction(constants_1.functions.VAULT_UPDATE);
            service.setAkordTags(tags);
            service.arweaveTags = yield service.getTxTags();
            const currentState = yield service.getCurrentState();
            const newState = lodash_1.default.cloneDeepWith(currentState);
            if (!newState.tags) {
                newState.tags = [];
            }
            for (const tag of tags) {
                if (newState.tags.indexOf(tag) === -1) {
                    newState.tags.push(tag);
                }
            }
            const dataTxId = yield service.uploadState(newState);
            const { id, object } = yield this.api.postContractTransaction(service.vaultId, { function: service.function, data: dataTxId }, service.arweaveTags);
            const vault = yield this.processVault(object, true, service.keys);
            return { transactionId: id, object: vault };
        });
    }
    /**
     * @param vaultId
     * @param tags tags to be removed
     * @returns Promise with corresponding transaction id
     */
    removeTags(vaultId, tags) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = new VaultService(this.wallet, this.api);
            yield service.setVaultContext(vaultId);
            service.setActionRef(constants_1.actionRefs.VAULT_REMOVE_TAGS);
            service.setFunction(constants_1.functions.VAULT_UPDATE);
            service.arweaveTags = yield service.getTxTags();
            const currentState = yield service.getCurrentState();
            const newState = lodash_1.default.cloneDeepWith(currentState);
            if (!newState.tags || newState.tags.length === 0) {
                throw new bad_request_1.BadRequest("Tags cannot be removed, vault does not have any");
            }
            for (const tag of tags) {
                const index = this.getTagIndex(newState.tags, tag);
                newState.tags.splice(index, 1);
            }
            const dataTxId = yield service.uploadState(newState);
            const { id, object } = yield this.api.postContractTransaction(service.vaultId, { function: service.function, data: dataTxId }, service.arweaveTags);
            const vault = yield this.processVault(object, true, service.keys);
            return { transactionId: id, object: vault };
        });
    }
    /**
     * @param  {string} vaultId
     * @returns Promise with corresponding transaction id
     */
    archive(vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = new VaultService(this.wallet, this.api);
            yield service.setVaultContext(vaultId);
            service.setActionRef(constants_1.actionRefs.VAULT_ARCHIVE);
            service.setFunction(constants_1.functions.VAULT_ARCHIVE);
            const { id, object } = yield this.api.postContractTransaction(service.vaultId, { function: service.function }, yield service.getTxTags());
            const vault = yield this.processVault(object, true, service.keys);
            return { transactionId: id, object: vault };
        });
    }
    /**
     * @param  {string} vaultId
     * @returns Promise with corresponding transaction id
     */
    restore(vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = new VaultService(this.wallet, this.api);
            yield service.setVaultContext(vaultId);
            service.setActionRef(constants_1.actionRefs.VAULT_RESTORE);
            service.setFunction(constants_1.functions.VAULT_RESTORE);
            const { id, object } = yield this.api.postContractTransaction(service.vaultId, { function: service.function }, yield service.getTxTags());
            const vault = yield this.processVault(object, true, service.keys);
            return { transactionId: id, object: vault };
        });
    }
    /**
     * @param  {string} vaultId
     * @returns Promise with corresponding transaction id
     */
    delete(vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.api.deleteVault(vaultId);
            return { transactionId: "" };
        });
    }
    setVaultContext(vaultId) {
        const _super = Object.create(null, {
            setVaultContext: { get: () => super.setVaultContext }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super.setVaultContext.call(this, vaultId);
            this.setObjectId(vaultId);
            this.setObject(this.vault);
        });
    }
    processVault(object, shouldDecrypt, keys) {
        return __awaiter(this, void 0, void 0, function* () {
            const vault = new vault_1.Vault(object, keys);
            if (shouldDecrypt && !vault.public) {
                try {
                    yield vault.decrypt();
                }
                catch (error) {
                    throw new incorrect_encryption_key_1.IncorrectEncryptionKey(error);
                }
            }
            return vault;
        });
    }
    getTagIndex(tags, tag) {
        const index = tags.indexOf(tag);
        if (index === -1) {
            throw new not_found_1.NotFound("Could not find tag: " + tag + " for given vault.");
        }
        return index;
    }
}
exports.VaultService = VaultService;
;
