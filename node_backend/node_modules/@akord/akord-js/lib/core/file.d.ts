import { Service } from "./service";
import { FileLike, FileSource } from "../types/file";
import { Tags } from "../types/contract";
import { FileVersion } from "../types/node";
import { UDL } from "../types/udl";
declare class FileService extends Service {
    asyncUploadTreshold: number;
    chunkSize: number;
    contentType: string;
    /**
     * Returns file as ArrayBuffer. Puts the whole file into memory.
     * For downloading without putting whole file to memory use FileService#download()
     * @param  {string} id file resource url
     * @param  {string} vaultId
     * @param  {DownloadOptions} [options]
     * @returns Promise with file buffer
     */
    get(id: string, vaultId: string, options?: DownloadOptions): Promise<ArrayBuffer>;
    /**
     * Downloads the file keeping memory consumed (RAM) under defiend level: this#chunkSize.
     * In browser, streaming of the binary requires self hosting of mitm.html and sw.js
     * See: https://github.com/jimmywarting/StreamSaver.js#configuration
     * @param  {string} id file resource url
     * @param  {string} vaultId
     * @param  {DownloadOptions} [options]
     * @returns Promise with file buffer
     */
    download(id: string, vaultId: string, options?: DownloadOptions): Promise<void>;
    create(file: FileLike, options: FileUploadOptions): Promise<FileUploadResult>;
    import(fileTxId: string): Promise<{
        file: FileLike;
        resourceHash: string;
        resourceUrl: string;
    }>;
    stream(path: string, size?: number): Promise<any | WritableStreamDefaultWriter>;
    newVersion(file: FileLike, uploadResult: FileUploadResult): Promise<FileVersion>;
    private retrieveFileMetadata;
    private retrieveFileType;
    private retrieveDecodedTag;
    private uploadChunked;
    private uploadChunk;
    private encryptChunk;
    private appendBuffer;
    private getBinary;
    private getFileTags;
}
declare type DownloadOptions = FileDownloadOptions & {
    name?: string;
};
export declare type FileUploadResult = {
    resourceTx?: string;
    resourceUrl?: string;
    resourceHash?: string;
    numberOfChunks?: number;
    chunkSize?: number;
    udl?: UDL;
};
export declare type Hooks = {
    progressHook?: (progress: number, data?: any) => void;
    cancelHook?: AbortController;
};
export declare type FileOptions = {
    name?: string;
    mimeType?: string;
    lastModified?: number;
};
export declare type FileUploadOptions = FileOptions & Hooks & {
    public?: boolean;
    cacheOnly?: boolean;
    arweaveTags?: Tags;
    udl?: UDL;
    ucm?: boolean;
};
export declare type FileDownloadOptions = Hooks & {
    public?: boolean;
    isChunked?: boolean;
    numberOfChunks?: number;
    loadedSize?: number;
    resourceSize?: number;
};
declare function createFileLike(source: FileSource, options?: FileOptions): Promise<FileLike>;
export { FileService, createFileLike };
