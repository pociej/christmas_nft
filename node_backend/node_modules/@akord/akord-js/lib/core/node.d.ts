import { Service } from './service';
import { NodeLike, NodeType } from '../types/node';
import { EncryptedKeys } from '@akord/crypto';
import { GetOptions, ListOptions } from '../types/query-options';
import { Tags } from '../types/contract';
import { Paginated } from '../types/paginated';
declare class NodeService<T> extends Service {
    objectType: NodeType;
    parentId?: string;
    defaultListOptions: ListOptions;
    defaultGetOptions: GetOptions;
    defaultCreateOptions: NodeCreateOptions;
    /**
     * @param  {string} nodeId
     * @returns Promise with the decrypted node
     */
    get(nodeId: string, options?: GetOptions): Promise<T>;
    /**
     * @param  {string} vaultId
     * @param  {ListOptions} options
     * @returns Promise with paginated nodes within given vault
     */
    list(vaultId: string, options?: ListOptions): Promise<Paginated<T>>;
    /**
     * @param  {string} vaultId
     * @param  {ListOptions} options
     * @returns Promise with all nodes within given vault
     */
    listAll(vaultId: string, options?: ListOptions): Promise<Array<T>>;
    /**
     * @param  {string} nodeId
     * @param  {string} name new name
     * @returns Promise with corresponding transaction id
     */
    rename(nodeId: string, name: string): Promise<NodeUpdateResult>;
    /**
     * @param  {string} nodeId
     * @param  {string} [parentId] new parent folder id
     * @returns Promise with corresponding transaction id
     */
    move(nodeId: string, parentId?: string, vaultId?: string): Promise<NodeUpdateResult>;
    /**
     * @param  {string} nodeId
     * @returns Promise with corresponding transaction id
     */
    revoke(nodeId: string, vaultId?: string): Promise<NodeUpdateResult>;
    /**
     * @param  {string} nodeId
     * @returns Promise with corresponding transaction id
     */
    restore(nodeId: string, vaultId?: string): Promise<NodeUpdateResult>;
    /**
     * @param  {string} nodeId
     * @returns Promise with corresponding transaction id
     */
    delete(nodeId: string, vaultId?: string): Promise<NodeUpdateResult>;
    protected nodeCreate<T>(state?: any, clientInput?: {
        parentId?: string;
    }, clientTags?: Tags): Promise<{
        nodeId: string;
        transactionId: string;
        object: T;
    }>;
    protected nodeUpdate<T>(stateUpdates?: any, clientInput?: {
        parentId?: string;
    }): Promise<{
        transactionId: string;
        object: T;
    }>;
    setParentId(parentId?: string): Promise<void>;
    protected setVaultContextFromNodeId(nodeId: string, type: NodeType, vaultId?: string): Promise<void>;
    getTxTags(): Promise<Tags>;
    processNode(object: NodeLike, shouldDecrypt: boolean, keys?: EncryptedKeys[]): Promise<T>;
    protected NodeType: new (arg0: any, arg1: EncryptedKeys[]) => NodeLike;
    private nodeInstance;
}
declare type NodeUpdateResult = {
    transactionId: string;
    object: NodeLike;
};
export declare type NodeCreateOptions = {
    parentId?: string;
    tags?: string[];
    arweaveTags?: Tags;
};
export { NodeService };
