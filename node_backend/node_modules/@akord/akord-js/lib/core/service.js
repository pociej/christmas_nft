"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Service = exports.STATE_CONTENT_TYPE = void 0;
const crypto_1 = require("@akord/crypto");
const constants_1 = require("../constants");
const contract_1 = require("../types/contract");
const incorrect_encryption_key_1 = require("../errors/incorrect-encryption-key");
const common_1 = require("./common");
exports.STATE_CONTENT_TYPE = "application/json";
class Service {
    constructor(wallet, api, service, encryptionKeys) {
        this.wallet = wallet;
        this.api = api;
        // for the data encryption
        this.dataEncrypter = new crypto_1.Encrypter(wallet, encryptionKeys === null || encryptionKeys === void 0 ? void 0 : encryptionKeys.keys, encryptionKeys === null || encryptionKeys === void 0 ? void 0 : encryptionKeys.getPublicKey());
        // set context from another service
        if (service) {
            this.setVault(service.vault);
            this.setVaultId(service.vaultId);
            this.setIsPublic(service.isPublic);
            this.setKeys(service.keys);
            this.setRawDataEncryptionPublicKey(service.dataEncrypter.publicKey);
            this.setFunction(service.function);
            this.setActionRef(service.actionRef);
            this.setObjectId(service.objectId);
            this.setObject(service.object);
            this.setGroupRef(service.groupRef);
            this.setAkordTags(service.tags);
        }
    }
    setKeys(keys) {
        this.keys = keys;
        this.dataEncrypter.setKeys(keys);
    }
    setVaultId(vaultId) {
        this.vaultId = vaultId;
    }
    setObjectId(objectId) {
        this.objectId = objectId;
    }
    setGroupRef(groupRef) {
        this.groupRef = groupRef;
    }
    setActionRef(actionRef) {
        this.actionRef = actionRef;
    }
    setObjectType(objectType) {
        this.objectType = objectType;
    }
    setFunction(functionName) {
        this.function = functionName;
    }
    setObject(object) {
        this.object = object;
    }
    setIsPublic(isPublic) {
        this.isPublic = isPublic;
    }
    setVault(vault) {
        this.vault = vault;
    }
    setRawDataEncryptionPublicKey(publicKey) {
        this.dataEncrypter.setRawPublicKey(publicKey);
    }
    setAkordTags(tags) {
        this.tags = tags;
    }
    processWriteString(data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isPublic)
                return data;
            let encryptedPayload;
            try {
                encryptedPayload = (yield this.dataEncrypter.encryptRaw((0, crypto_1.stringToArray)(data)));
            }
            catch (error) {
                throw new incorrect_encryption_key_1.IncorrectEncryptionKey(error);
            }
            const decodedPayload = (0, crypto_1.base64ToJson)(encryptedPayload);
            decodedPayload.publicAddress = (yield this.getActiveKey()).address;
            delete decodedPayload.publicKey;
            return (0, crypto_1.jsonToBase64)(decodedPayload);
        });
    }
    setVaultContext(vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            const vault = yield this.api.getVault(vaultId);
            this.setVault(vault);
            this.setVaultId(vaultId);
            this.setIsPublic(vault.public);
            yield this.setMembershipKeys(vault);
        });
    }
    setMembershipKeys(object) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isPublic) {
                const keys = object.__keys__.map(((keyPair) => {
                    return {
                        encPrivateKey: keyPair.encPrivateKey,
                        encPublicKey: keyPair.publicKey ? keyPair.publicKey : keyPair.encPublicKey
                    };
                }));
                this.setKeys(keys);
                try {
                    if (object.__publicKey__) {
                        this.setRawDataEncryptionPublicKey((0, crypto_1.base64ToArray)(object.__publicKey__));
                    }
                    else {
                        const currentEncPublicKey = object.__keys__[object.__keys__.length - 1].encPublicKey;
                        const publicKey = yield this.dataEncrypter.wallet.decrypt(currentEncPublicKey);
                        this.setRawDataEncryptionPublicKey(publicKey);
                    }
                }
                catch (error) {
                    throw new incorrect_encryption_key_1.IncorrectEncryptionKey(error);
                }
            }
        });
    }
    uploadState(state, cacheOnly = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const signature = yield this.signData(state);
            const tags = [
                new contract_1.Tag(constants_1.dataTags.DATA_TYPE, "State"),
                new contract_1.Tag(constants_1.smartweaveTags.CONTENT_TYPE, exports.STATE_CONTENT_TYPE),
                new contract_1.Tag(constants_1.protocolTags.SIGNATURE, signature),
                new contract_1.Tag(constants_1.protocolTags.SIGNER_ADDRESS, yield this.wallet.getAddress()),
                new contract_1.Tag(constants_1.protocolTags.VAULT_ID, this.vaultId),
                new contract_1.Tag(constants_1.protocolTags.NODE_TYPE, this.objectType),
            ];
            if (this.objectType === constants_1.objectType.MEMBERSHIP) {
                tags.push(new contract_1.Tag(constants_1.protocolTags.MEMBERSHIP_ID, this.objectId));
            }
            else if (this.objectType !== constants_1.objectType.VAULT) {
                tags.push(new contract_1.Tag(constants_1.protocolTags.NODE_ID, this.objectId));
            }
            const ids = yield this.api.uploadData([{ data: state, tags }], { cacheOnly });
            return ids[0];
        });
    }
    getTxTags() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const tags = [
                new contract_1.Tag(constants_1.protocolTags.FUNCTION_NAME, this.function),
                new contract_1.Tag(constants_1.protocolTags.SIGNER_ADDRESS, yield this.wallet.getAddress()),
                new contract_1.Tag(constants_1.protocolTags.VAULT_ID, this.vaultId),
                new contract_1.Tag(constants_1.protocolTags.TIMESTAMP, JSON.stringify(Date.now())),
                new contract_1.Tag(constants_1.protocolTags.NODE_TYPE, this.objectType),
                new contract_1.Tag(constants_1.protocolTags.PUBLIC, this.isPublic ? "true" : "false"),
            ];
            if (this.groupRef) {
                tags.push(new contract_1.Tag(constants_1.protocolTags.GROUP_REF, this.groupRef));
            }
            if (this.actionRef) {
                tags.push(new contract_1.Tag(constants_1.protocolTags.ACTION_REF, this.actionRef));
            }
            (_b = (_a = this.tags) === null || _a === void 0 ? void 0 : _a.filter(tag => tag)) === null || _b === void 0 ? void 0 : _b.map((tag) => tag === null || tag === void 0 ? void 0 : tag.split(" ").join(",").split(".").join(",").split(",").map((value) => tags.push(new contract_1.Tag(constants_1.AKORD_TAG, value.toLowerCase()))));
            // remove duplicates
            return [...new Map(tags.map(item => [item.value, item])).values()];
        });
    }
    processWriteRaw(data, encryptedKey) {
        return __awaiter(this, void 0, void 0, function* () {
            let processedData;
            const tags = [];
            if (this.isPublic) {
                processedData = data;
            }
            else {
                let encryptedFile;
                try {
                    encryptedFile = (yield this.dataEncrypter.encryptRaw(new Uint8Array(data), false, encryptedKey));
                }
                catch (error) {
                    throw new incorrect_encryption_key_1.IncorrectEncryptionKey(error);
                }
                processedData = encryptedFile.encryptedData.ciphertext;
                const { address } = yield this.getActiveKey();
                tags.push(new contract_1.Tag(constants_1.encryptionTags.IV, encryptedFile.encryptedData.iv));
                tags.push(new contract_1.Tag(constants_1.encryptionTags.ENCRYPTED_KEY, encryptedFile.encryptedKey));
                tags.push(new contract_1.Tag(constants_1.encryptionTags.PUBLIC_ADDRESS, address));
            }
            return { processedData, encryptionTags: tags };
        });
    }
    processReadRaw(data, metadata, shouldDecrypt = true) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isPublic || !shouldDecrypt) {
                return data;
            }
            const encryptedPayload = (0, common_1.getEncryptedPayload)(data, metadata);
            try {
                if (encryptedPayload) {
                    return this.dataEncrypter.decryptRaw(encryptedPayload, false);
                }
                else {
                    return this.dataEncrypter.decryptRaw(data);
                }
            }
            catch (error) {
                throw new incorrect_encryption_key_1.IncorrectEncryptionKey(error);
            }
        });
    }
    processReadString(data, shouldDecrypt = true) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isPublic || !shouldDecrypt)
                return data;
            const decryptedDataRaw = yield this.processReadRaw(data, {});
            return (0, crypto_1.arrayToString)(decryptedDataRaw);
        });
    }
    getActiveKey() {
        return __awaiter(this, void 0, void 0, function* () {
            return {
                address: yield (0, crypto_1.deriveAddress)(this.dataEncrypter.publicKey),
                publicKey: (0, crypto_1.arrayToBase64)(this.dataEncrypter.publicKey)
            };
        });
    }
    getCurrentState() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            return ((_b = (_a = this.object) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.length) > 0
                ? yield this.api.getNodeState(this.object.data[this.object.data.length - 1])
                : {};
        });
    }
    mergeAndUploadState(stateUpdates) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentState = yield this.getCurrentState();
            const mergedState = (0, common_1.mergeState)(currentState, stateUpdates);
            return this.uploadState(mergedState);
        });
    }
    signData(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const privateKeyRaw = this.wallet.signingPrivateKeyRaw();
            const signature = yield (0, crypto_1.signString)((0, crypto_1.jsonToBase64)(data), privateKeyRaw);
            return signature;
        });
    }
}
exports.Service = Service;
