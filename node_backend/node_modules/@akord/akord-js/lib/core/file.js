"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFileLike = exports.FileService = void 0;
const mime = __importStar(require("mime-types"));
const uuid_1 = require("uuid");
const stream_1 = require("stream");
const crypto_1 = require("@akord/crypto");
const service_1 = require("./service");
const constants_1 = require("../constants");
const logger_1 = require("../logger");
const api_client_1 = require("../api/api-client");
const contract_1 = require("../types/contract");
const arweave_1 = require("../arweave");
const manifest_1 = require("./manifest");
const node_1 = require("../types/node");
const udl_1 = require("./udl");
const bad_request_1 = require("../errors/bad-request");
const DEFAULT_FILE_TYPE = "text/plain";
class FileService extends service_1.Service {
    constructor() {
        super(...arguments);
        this.asyncUploadTreshold = 209715200;
        this.chunkSize = 209715200;
        this.contentType = null;
    }
    /**
     * Returns file as ArrayBuffer. Puts the whole file into memory.
     * For downloading without putting whole file to memory use FileService#download()
     * @param  {string} id file resource url
     * @param  {string} vaultId
     * @param  {DownloadOptions} [options]
     * @returns Promise with file buffer
     */
    get(id, vaultId, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = new FileService(this.wallet, this.api);
            yield service.setVaultContext(vaultId);
            const downloadOptions = options;
            downloadOptions.public = service.isPublic;
            let fileBinary;
            if (options.isChunked) {
                let currentChunk = 0;
                while (currentChunk < options.numberOfChunks) {
                    const url = `${id}_${currentChunk}`;
                    downloadOptions.loadedSize = currentChunk * this.chunkSize;
                    const chunkBinary = yield service.getBinary(url, downloadOptions);
                    fileBinary = service.appendBuffer(fileBinary, chunkBinary);
                    currentChunk++;
                }
            }
            else {
                const { fileData, metadata } = yield this.api.downloadFile(id, downloadOptions);
                fileBinary = yield service.processReadRaw(fileData, metadata);
            }
            return fileBinary;
        });
    }
    /**
     * Downloads the file keeping memory consumed (RAM) under defiend level: this#chunkSize.
     * In browser, streaming of the binary requires self hosting of mitm.html and sw.js
     * See: https://github.com/jimmywarting/StreamSaver.js#configuration
     * @param  {string} id file resource url
     * @param  {string} vaultId
     * @param  {DownloadOptions} [options]
     * @returns Promise with file buffer
     */
    download(id, vaultId, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = new FileService(this.wallet, this.api);
            yield service.setVaultContext(vaultId);
            const downloadOptions = options;
            downloadOptions.public = service.isPublic;
            const writer = yield service.stream(options.name, options.resourceSize);
            if (options.isChunked) {
                let currentChunk = 0;
                try {
                    while (currentChunk < options.numberOfChunks) {
                        const url = `${id}_${currentChunk}`;
                        downloadOptions.loadedSize = currentChunk * service.chunkSize;
                        const fileBinary = yield service.getBinary(url, downloadOptions);
                        if (writer instanceof WritableStreamDefaultWriter) {
                            yield writer.ready;
                        }
                        yield writer.write(new Uint8Array(fileBinary));
                        currentChunk++;
                    }
                }
                catch (err) {
                    throw new Error(err);
                }
                finally {
                    if (writer instanceof WritableStreamDefaultWriter) {
                        yield writer.ready;
                    }
                    yield writer.close();
                }
            }
            else {
                const fileBinary = yield service.getBinary(id, downloadOptions);
                yield writer.write(new Uint8Array(fileBinary));
                yield writer.close();
            }
        });
    }
    create(file, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const tags = this.getFileTags(file, options);
            if (file.size > this.asyncUploadTreshold) {
                return yield this.uploadChunked(file, tags, options);
            }
            else {
                const { processedData, encryptionTags } = yield this.processWriteRaw(yield file.arrayBuffer());
                const resourceHash = yield (0, crypto_1.digestRaw)(new Uint8Array(processedData));
                const privateKeyRaw = this.wallet.signingPrivateKeyRaw();
                const signature = yield (0, crypto_1.signHash)((0, crypto_1.base64ToArray)(resourceHash), privateKeyRaw);
                tags.push(new contract_1.Tag(constants_1.fileTags.FILE_HASH, resourceHash));
                tags.push(new contract_1.Tag(constants_1.protocolTags.SIGNATURE, signature));
                tags.push(new contract_1.Tag(constants_1.protocolTags.SIGNER_ADDRESS, yield this.wallet.getAddress()));
                options.public = this.isPublic;
                return Object.assign({ resourceHash: resourceHash, udl: options.udl }, yield this.api.uploadFile(processedData, tags.concat(encryptionTags), options));
            }
        });
    }
    import(fileTxId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const fileData = yield (0, arweave_1.getTxData)(fileTxId);
            const fileMetadata = yield (0, arweave_1.getTxMetadata)(fileTxId);
            const { name, type } = this.retrieveFileMetadata(fileTxId, fileMetadata === null || fileMetadata === void 0 ? void 0 : fileMetadata.tags);
            const file = yield createFileLike([fileData], { name, mimeType: type, lastModified: (_a = fileMetadata === null || fileMetadata === void 0 ? void 0 : fileMetadata.block) === null || _a === void 0 ? void 0 : _a.timestamp });
            const tags = this.getFileTags(file);
            const { processedData, encryptionTags } = yield this.processWriteRaw(yield file.arrayBuffer());
            const resourceHash = yield (0, crypto_1.digestRaw)(new Uint8Array(processedData));
            tags.push(new contract_1.Tag(constants_1.fileTags.FILE_HASH, resourceHash));
            const resource = yield new api_client_1.ApiClient()
                .env(this.api.config)
                .data(processedData)
                .tags(tags.concat(encryptionTags))
                .public(this.isPublic)
                .cacheOnly(true)
                .uploadFile();
            return { file, resourceHash, resourceUrl: resource.resourceUrl };
        });
    }
    stream(path, size) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof window === 'undefined') {
                const fs = (yield Promise.resolve().then(() => __importStar(require("fs")))).default;
                return fs.createWriteStream(path);
            }
            else {
                const streamSaver = (yield Promise.resolve().then(() => __importStar(require('streamsaver')))).default;
                if (!streamSaver.WritableStream) {
                    const pony = yield Promise.resolve().then(() => __importStar(require('web-streams-polyfill/ponyfill')));
                    streamSaver.WritableStream = pony.WritableStream;
                }
                if (window.location.protocol === 'https:'
                    || window.location.protocol === 'chrome-extension:'
                    || window.location.hostname === 'localhost') {
                    streamSaver.mitm = '/streamsaver/mitm.html';
                }
                const fileStream = streamSaver.createWriteStream(path, { size: size, writableStrategy: new ByteLengthQueuingStrategy({ highWaterMark: 3 * this.chunkSize }) });
                return fileStream.getWriter();
            }
        });
    }
    newVersion(file, uploadResult) {
        return __awaiter(this, void 0, void 0, function* () {
            const version = new node_1.FileVersion({
                owner: yield this.wallet.getAddress(),
                createdAt: JSON.stringify(Date.now()),
                name: yield this.processWriteString(file.name),
                type: file.type,
                size: file.size,
                resourceUri: [
                    `arweave:${uploadResult.resourceTx}`,
                    `hash:${uploadResult.resourceHash}`,
                    `s3:${uploadResult.resourceUrl}`
                ],
                numberOfChunks: uploadResult.numberOfChunks,
                chunkSize: uploadResult.chunkSize,
                udl: uploadResult.udl
            });
            return version;
        });
    }
    retrieveFileMetadata(fileTxId, tags = []) {
        const type = this.retrieveFileType(tags);
        const name = this.retrieveDecodedTag(tags, "File-Name")
            || this.retrieveDecodedTag(tags, "Title")
            || this.retrieveDecodedTag(tags, "Name")
            || (fileTxId + "." + mime.extension(type));
        return { name, type };
    }
    retrieveFileType(tags = []) {
        const contentType = this.retrieveDecodedTag(tags, "Content-Type");
        return (contentType === manifest_1.CONTENT_TYPE ? manifest_1.FILE_TYPE : contentType)
            || DEFAULT_FILE_TYPE;
    }
    retrieveDecodedTag(tags, tagName) {
        var _a;
        const tagValue = (_a = tags === null || tags === void 0 ? void 0 : tags.find((tag) => tag.name === tagName)) === null || _a === void 0 ? void 0 : _a.value;
        if (tagValue) {
            return decodeURIComponent(tagValue);
        }
        return null;
    }
    uploadChunked(file, tags, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let resourceUrl = (0, uuid_1.v4)();
            let encryptionTags;
            let encryptedKey;
            let iv = [];
            let uploadedChunks = 0;
            let offset = 0;
            while (offset < file.size) {
                const chunk = file.slice(offset, this.chunkSize + offset);
                const { encryptedData, chunkNumber } = yield this.encryptChunk(chunk, offset, encryptedKey);
                encryptionTags = encryptedData.encryptionTags;
                if (!this.isPublic) {
                    iv.push(encryptionTags.find((tag) => tag.name === constants_1.encryptionTags.IV).value);
                    if (!encryptedKey) {
                        encryptedKey = encryptionTags.find((tag) => tag.name === constants_1.encryptionTags.ENCRYPTED_KEY).value;
                    }
                }
                yield this.uploadChunk(encryptedData, chunkNumber, tags, resourceUrl, file.size, options);
                offset += this.chunkSize;
                uploadedChunks += 1;
                logger_1.Logger.log("Encrypted & uploaded chunk: " + chunkNumber);
            }
            if (!this.isPublic) {
                const ivIndex = encryptionTags.findIndex((tag) => tag.name === constants_1.encryptionTags.IV);
                encryptionTags[ivIndex] = new contract_1.Tag(constants_1.encryptionTags.IV, iv.join(','));
            }
            yield new api_client_1.ApiClient()
                .env(this.api.config)
                .resourceId(resourceUrl)
                .tags(tags.concat(encryptionTags))
                .public(this.isPublic)
                .numberOfChunks(uploadedChunks)
                .asyncTransaction();
            return {
                resourceUrl: resourceUrl,
                resourceHash: resourceUrl,
                numberOfChunks: uploadedChunks,
                chunkSize: this.chunkSize
            };
        });
    }
    uploadChunk(chunk, chunkNumber, tags, resourceUrl, resourceSize, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const resource = yield new api_client_1.ApiClient()
                .env(this.api.config)
                .resourceId(`${resourceUrl}_${chunkNumber}`)
                .data(chunk.processedData)
                .tags(tags.concat(chunk.encryptionTags))
                .public(this.isPublic)
                .cacheOnly(true)
                .progressHook(options.progressHook, chunkNumber * this.chunkSize, resourceSize)
                .cancelHook(options.cancelHook)
                .uploadFile();
            logger_1.Logger.log("Uploaded file with id: " + resource.resourceUrl);
        });
    }
    encryptChunk(chunk, offset, encryptedKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const chunkNumber = offset / this.chunkSize;
            const arrayBuffer = yield chunk.arrayBuffer();
            const encryptedData = yield this.processWriteRaw(arrayBuffer, encryptedKey);
            return { encryptedData, chunkNumber };
        });
    }
    appendBuffer(buffer1, buffer2) {
        if (!buffer1 && !buffer2)
            return;
        if (!buffer1)
            return buffer2;
        if (!buffer2)
            return buffer1;
        var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
        tmp.set(new Uint8Array(buffer1), 0);
        tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
        return tmp.buffer;
    }
    getBinary(id, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                options.public = this.isPublic;
                const { fileData, metadata } = yield this.api.downloadFile(id, options);
                return yield this.processReadRaw(fileData, metadata);
            }
            catch (e) {
                logger_1.Logger.log(e);
                throw new Error("Failed to download. Please check your network connection." +
                    " Please upload the file again if problem persists and/or contact Akord support.");
            }
        });
    }
    getFileTags(file, options = {}) {
        var _a;
        const tags = [];
        if (this.isPublic) {
            tags.push(new contract_1.Tag(constants_1.fileTags.FILE_NAME, file.name));
            if (file.lastModified) {
                tags.push(new contract_1.Tag(constants_1.fileTags.FILE_MODIFIED_AT, file.lastModified.toString()));
            }
        }
        tags.push(new contract_1.Tag(constants_1.smartweaveTags.CONTENT_TYPE, this.contentType || file.type || DEFAULT_FILE_TYPE));
        tags.push(new contract_1.Tag(constants_1.fileTags.FILE_SIZE, file.size));
        tags.push(new contract_1.Tag(constants_1.fileTags.FILE_TYPE, file.type || DEFAULT_FILE_TYPE));
        tags.push(new contract_1.Tag(constants_1.protocolTags.TIMESTAMP, JSON.stringify(Date.now())));
        tags.push(new contract_1.Tag(constants_1.dataTags.DATA_TYPE, "File"));
        tags.push(new contract_1.Tag(constants_1.protocolTags.VAULT_ID, this.vaultId));
        (_a = options.arweaveTags) === null || _a === void 0 ? void 0 : _a.map((tag) => tags.push(tag));
        if (options.udl) {
            const udlTags = (0, udl_1.udlToTags)(options.udl);
            tags.push(...udlTags);
        }
        return tags;
    }
}
exports.FileService = FileService;
;
function createFileLike(source, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const mimeType = options.mimeType || mime.lookup(options.name) || '';
        if (typeof window !== "undefined") {
            if (source instanceof Uint8Array || source instanceof Buffer || source instanceof ArrayBuffer || source instanceof Blob) {
                if (!options.name) {
                    throw new bad_request_1.BadRequest("File name is required, please provide it in the file options.");
                }
                if (!mimeType) {
                    console.warn("Missing file mime type. If this is unintentional, please provide it in the file options.");
                }
                return new File([source], options.name, { type: mimeType, lastModified: options.lastModified });
            }
            else if (source instanceof File) {
                return source;
            }
            else if (source instanceof Array) {
                if (!options.name) {
                    throw new bad_request_1.BadRequest("File name is required, please provide it in the file options.");
                }
                if (!mimeType) {
                    console.warn("Missing file mime type. If this is unintentional, please provide it in the file options.");
                }
                return new File(source, options.name, { type: mimeType, lastModified: options.lastModified });
            }
        }
        else {
            const nodeJsFile = (yield Promise.resolve().then(() => __importStar(require("../types/file")))).NodeJs.File;
            if (source instanceof stream_1.Readable) {
                return nodeJsFile.fromReadable(source, options.name, mimeType, options.lastModified);
            }
            else if (source instanceof Uint8Array || source instanceof Buffer || source instanceof ArrayBuffer) {
                return new nodeJsFile([source], options.name, mimeType, options.lastModified);
            }
            else if (source instanceof nodeJsFile) {
                return source;
            }
            else if (typeof source === "string") {
                return nodeJsFile.fromPath(source);
            }
            else if (source instanceof Array) {
                return new nodeJsFile(source, options.name, mimeType, options.lastModified);
            }
        }
        throw new bad_request_1.BadRequest("File source is not supported. Please provide a valid source: web File object, file path, buffer or stream.");
    });
}
exports.createFileLike = createFileLike;
