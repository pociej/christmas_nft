import { Api } from "../api/api";
import { Wallet, Encrypter, EncryptionKeys, EncryptedKeys } from "@akord/crypto";
import { functions } from '../constants';
import { Vault } from "../types/vault";
import { Tags } from "../types/contract";
import { NodeLike } from "../types/node";
import { Membership } from "../types/membership";
import { Object, ObjectType } from "../types/object";
export declare type EncryptionMetadata = {
    encryptedKey?: string;
    iv?: string;
};
export declare const STATE_CONTENT_TYPE = "application/json";
declare class Service {
    api: Api;
    wallet: Wallet;
    dataEncrypter: Encrypter;
    keys: Array<EncryptedKeys>;
    vaultId: string;
    objectId: string;
    objectType: ObjectType;
    function: functions;
    isPublic: boolean;
    vault: Vault;
    object: Object;
    actionRef: string;
    groupRef: string;
    tags: string[];
    arweaveTags: Tags;
    constructor(wallet: Wallet, api: Api, service?: Service, encryptionKeys?: EncryptionKeys);
    setKeys(keys: EncryptedKeys[]): void;
    setVaultId(vaultId: string): void;
    setObjectId(objectId: string): void;
    setGroupRef(groupRef: string): void;
    setActionRef(actionRef: string): void;
    setObjectType(objectType: ObjectType): void;
    setFunction(functionName: functions): void;
    setObject(object: NodeLike | Membership | Vault): void;
    setIsPublic(isPublic: boolean): void;
    setVault(vault: Vault): void;
    setRawDataEncryptionPublicKey(publicKey: Uint8Array): void;
    setAkordTags(tags: string[]): void;
    processWriteString(data: string): Promise<string>;
    setVaultContext(vaultId: string): Promise<void>;
    setMembershipKeys(object: Object): Promise<void>;
    uploadState(state: any, cacheOnly?: boolean): Promise<string>;
    getTxTags(): Promise<Tags>;
    protected processWriteRaw(data: ArrayBuffer, encryptedKey?: string): Promise<{
        processedData: ArrayBuffer;
        encryptionTags: Tags;
    }>;
    protected processReadRaw(data: ArrayBuffer | string, metadata: EncryptionMetadata, shouldDecrypt?: boolean): Promise<ArrayBuffer>;
    protected processReadString(data: string, shouldDecrypt?: boolean): Promise<string>;
    protected getActiveKey(): Promise<{
        address: string;
        publicKey: string;
    }>;
    protected getCurrentState(): Promise<any>;
    protected mergeAndUploadState(stateUpdates: any): Promise<string>;
    private signData;
}
export { Service };
