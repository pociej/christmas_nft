import { objectType } from "../constants";
import { EncryptedKeys } from "@akord/crypto";
import { Vault } from "../types/vault";
import { Service } from "./service";
import { Tags } from "../types/contract";
import { ListOptions, VaultGetOptions } from "../types/query-options";
import { Paginated } from "../types/paginated";
declare class VaultService extends Service {
    objectType: objectType;
    defaultListOptions: ListOptions;
    defaultGetOptions: VaultGetOptions;
    defaultCreateOptions: VaultCreateOptions;
    /**
     * @param  {string} vaultId
     * @returns Promise with the decrypted vault
     */
    get(vaultId: string, options?: VaultGetOptions): Promise<Vault>;
    /**
     * @param  {ListOptions} options
     * @returns Promise with paginated user vaults
     */
    list(options?: ListOptions): Promise<Paginated<Vault>>;
    /**
     * @param  {ListOptions} options
     * @returns Promise with currently authenticated user vaults
     */
    listAll(options?: ListOptions): Promise<Array<Vault>>;
    /**
     * @param  {string} name new vault name
     * @param  {VaultCreateOptions} options public/private, terms of access, etc.
     * @returns Promise with new vault id, owner membership id & corresponding transaction id
     */
    create(name: string, options?: VaultCreateOptions): Promise<VaultCreateResult>;
    /**
     * @param  {string} vaultId
     * @param  {VaultUpdateOptions} options name, description & tags
     * @returns Promise with corresponding transaction id
     */
    update(vaultId: string, options: VaultUpdateOptions): Promise<VaultUpdateResult>;
    /**
     * @param vaultId
     * @param name new vault name
     * @returns Promise with corresponding transaction id
     */
    rename(vaultId: string, name: string): Promise<VaultUpdateResult>;
    /**
     * @param vaultId
     * @param tags tags to be added
     * @returns Promise with corresponding transaction id
     */
    addTags(vaultId: string, tags: string[]): Promise<VaultUpdateResult>;
    /**
     * @param vaultId
     * @param tags tags to be removed
     * @returns Promise with corresponding transaction id
     */
    removeTags(vaultId: string, tags: string[]): Promise<VaultUpdateResult>;
    /**
     * @param  {string} vaultId
     * @returns Promise with corresponding transaction id
     */
    archive(vaultId: string): Promise<VaultUpdateResult>;
    /**
     * @param  {string} vaultId
     * @returns Promise with corresponding transaction id
     */
    restore(vaultId: string): Promise<VaultUpdateResult>;
    /**
     * @param  {string} vaultId
     * @returns Promise with corresponding transaction id
     */
    delete(vaultId: string): Promise<{
        transactionId: string;
    }>;
    setVaultContext(vaultId: string): Promise<void>;
    protected processVault(object: Vault, shouldDecrypt: boolean, keys?: EncryptedKeys[]): Promise<Vault>;
    private getTagIndex;
}
export declare type VaultCreateOptions = {
    public?: boolean;
    termsOfAccess?: string;
    description?: string;
    tags?: string[];
    cacheOnly?: boolean;
    arweaveTags?: Tags;
};
export declare type VaultUpdateOptions = {
    name?: string;
    description?: string;
    tags?: string[];
};
declare type VaultCreateResult = {
    vaultId: string;
    membershipId: string;
    transactionId: string;
    object: Vault;
};
declare type VaultUpdateResult = {
    transactionId: string;
    object: Vault;
};
export { VaultService };
