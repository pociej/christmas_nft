"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemoService = void 0;
const node_1 = require("./node");
const constants_1 = require("../constants");
const lodash_1 = __importDefault(require("lodash"));
const node_2 = require("../types/node");
const not_found_1 = require("../errors/not-found");
const incorrect_encryption_key_1 = require("../errors/incorrect-encryption-key");
class MemoService extends node_1.NodeService {
    constructor() {
        super(...arguments);
        this.objectType = node_2.nodeType.MEMO;
        this.NodeType = node_2.Memo;
        this.defaultListOptions = {
            shouldDecrypt: true,
            filter: {}
        };
    }
    /**
     * @param  {string} vaultId
     * @param  {string} message
     * @param  {NodeCreateOptions} [options] parent id, etc.
     * @returns Promise with new node id & corresponding transaction id
     */
    create(vaultId, message, options = this.defaultCreateOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = new MemoService(this.wallet, this.api);
            yield service.setVaultContext(vaultId);
            service.setActionRef(constants_1.actionRefs.MEMO_CREATE);
            service.setFunction(constants_1.functions.NODE_CREATE);
            service.setAkordTags(options.tags);
            const state = {
                versions: [yield service.memoVersion(message)],
                tags: options.tags || []
            };
            const { nodeId, transactionId, object } = yield service.nodeCreate(state, { parentId: options.parentId }, options.arweaveTags);
            return { memoId: nodeId, transactionId, object };
        });
    }
    /**
     * @param  {string} memoId
     * @param  {reactionEmoji} reaction
     * @returns Promise with corresponding transaction id
     */
    addReaction(memoId, reaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = new MemoService(this.wallet, this.api);
            yield service.setVaultContextFromNodeId(memoId, this.objectType);
            service.setActionRef(constants_1.actionRefs.MEMO_ADD_REACTION);
            service.setFunction(constants_1.functions.NODE_UPDATE);
            service.arweaveTags = yield service.getTxTags();
            const currentState = yield service.getCurrentState();
            const newState = lodash_1.default.cloneDeepWith(currentState);
            newState.versions[newState.versions.length - 1].reactions.push(yield service.memoReaction(reaction));
            const dataTxId = yield service.uploadState(newState);
            const { id, object } = yield this.api.postContractTransaction(service.vaultId, { function: service.function, data: dataTxId }, service.arweaveTags);
            const memo = yield this.processMemo(object, !service.isPublic, service.keys);
            return { transactionId: id, object: memo };
        });
    }
    /**
     * @param  {string} memoId
     * @param  {reactionEmoji} reaction
     * @returns Promise with corresponding transaction id
     */
    removeReaction(memoId, reaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = new MemoService(this.wallet, this.api);
            yield service.setVaultContextFromNodeId(memoId, this.objectType);
            service.setActionRef(constants_1.actionRefs.MEMO_REMOVE_REACTION);
            service.setFunction(constants_1.functions.NODE_UPDATE);
            service.arweaveTags = yield service.getTxTags();
            const state = yield service.deleteReaction(reaction);
            const dataTxId = yield service.uploadState(state);
            const { id, object } = yield this.api.postContractTransaction(service.vaultId, { function: service.function, data: dataTxId }, service.arweaveTags);
            const memo = yield this.processMemo(object, !service.isPublic, service.keys);
            return { transactionId: id, object: memo };
        });
    }
    processMemo(object, shouldDecrypt, keys) {
        return __awaiter(this, void 0, void 0, function* () {
            const memo = new node_2.Memo(object, keys);
            if (shouldDecrypt) {
                try {
                    yield memo.decrypt();
                }
                catch (error) {
                    throw new incorrect_encryption_key_1.IncorrectEncryptionKey(error);
                }
            }
            return memo;
        });
    }
    memoVersion(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const version = {
                owner: yield this.wallet.getAddress(),
                message: yield this.processWriteString(message),
                createdAt: JSON.stringify(Date.now()),
                reactions: [],
                attachments: []
            };
            return new node_2.MemoVersion(version);
        });
    }
    memoReaction(reactionEmoji) {
        return __awaiter(this, void 0, void 0, function* () {
            const reaction = {
                reaction: yield this.processWriteString(reactionEmoji),
                owner: yield this.wallet.getAddress(),
                createdAt: JSON.stringify(Date.now())
            };
            return new node_2.MemoReaction(reaction);
        });
    }
    deleteReaction(reaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentState = yield this.getCurrentState();
            const index = yield this.getReactionIndex(currentState.versions[currentState.versions.length - 1].reactions, reaction);
            const newState = lodash_1.default.cloneDeepWith(currentState);
            newState.versions[newState.versions.length - 1].reactions.splice(index, 1);
            return newState;
        });
    }
    getReactionIndex(reactions, reaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.wallet.getAddress();
            const publicSigningKey = this.wallet.signingPublicKey();
            for (const [key, value] of Object.entries(reactions)) {
                if ((value.owner === address || value.address === address || value.publicSigningKey === publicSigningKey)
                    && reaction === (yield this.processReadString(value.reaction))) {
                    return key;
                }
            }
            throw new not_found_1.NotFound("Could not find reaction: " + reaction + " for given user.");
        });
    }
}
exports.MemoService = MemoService;
MemoService.reactionEmoji = constants_1.reactionEmoji;
;
