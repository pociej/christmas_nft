"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiClient = void 0;
const axios_1 = __importDefault(require("axios"));
const uuid_1 = require("uuid");
const paginated_1 = require("../types/paginated");
const akord_auth_1 = require("@akord/akord-auth");
const unauthorized_1 = require("../errors/unauthorized");
const error_factory_1 = require("../errors/error-factory");
const bad_request_1 = require("../errors/bad-request");
const not_found_1 = require("../errors/not-found");
class ApiClient {
    constructor() {
        this._dir = "files";
        this._filesDir = "files";
        this._publicDataDir = "public";
        this._contractUri = "contracts";
        this._transactionUri = "transactions";
        this._stateDir = "states";
        this._queryParams = {};
        this._responseType = "json";
        this.addQueryParams = function (url, params) {
            const queryParams = new URLSearchParams(JSON.parse(JSON.stringify(params)));
            url += "?" + queryParams.toString();
            return url;
        };
    }
    env(config) {
        this._apiurl = config.apiurl;
        this._storageurl = config.storageurl;
        return this;
    }
    resourceId(resourceId) {
        this._resourceId = resourceId;
        return this;
    }
    public(isPublic) {
        this._isPublic = isPublic;
        return this;
    }
    cacheOnly(cacheOnly) {
        this._cacheOnly = cacheOnly;
        this.queryParams({ cacheOnly: cacheOnly });
        return this;
    }
    asArrayBuffer() {
        this.setResponseType("arraybuffer");
        return this;
    }
    vaultId(vaultId) {
        this._vaultId = vaultId;
        return this;
    }
    data(data) {
        this._data = data;
        return this;
    }
    metadata(metadata) {
        this._metadata = metadata;
        if (metadata === null || metadata === void 0 ? void 0 : metadata.cacheOnly) {
            this.cacheOnly(metadata.cacheOnly);
        }
        return this;
    }
    queryParams(queryParams) {
        if (queryParams) {
            this._queryParams = Object.assign(Object.assign({}, this._queryParams), queryParams);
        }
        else {
            this._queryParams = {};
        }
        return this;
    }
    tags(tags) {
        this._tags = tags;
        return this;
    }
    setResponseType(responseType) {
        this._responseType = responseType;
        return this;
    }
    progressHook(hook, processed, total) {
        this._progressHook = hook;
        this._processed = processed;
        this._total = total;
        return this;
    }
    cancelHook(hook) {
        this._cancelHook = hook;
        return this;
    }
    input(input) {
        this._input = input;
        return this;
    }
    numberOfChunks(numberOfChunks) {
        this._numberOfChunks = numberOfChunks;
        return this;
    }
    /**
     *
     * @requires:
     * - auth()
     * @uses:
     * - data()
     */
    contract() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.post(`${this._apiurl}/vaults`);
            return response.id;
        });
    }
    getContract() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.public(true).get(`${this._storageurl}/${this._contractUri}/${this._vaultId}`);
        });
    }
    existsUser() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.get(`${this._apiurl}/users`);
            }
            catch (e) {
                if (!(e instanceof not_found_1.NotFound)) {
                    throw e;
                }
                return false;
            }
            return true;
        });
    }
    getUser() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`${this._apiurl}/users`);
        });
    }
    getUserPublicData() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`${this._apiurl}/users`);
        });
    }
    updateUser() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.fetch("put", `${this._apiurl}/users`);
        });
    }
    deleteVault() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.delete(`${this._apiurl}/vaults/${this._vaultId}`);
        });
    }
    getMembers() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`${this._apiurl}/vaults/${this._vaultId}/members`);
        });
    }
    getNotifications() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`${this._apiurl}/notifications`);
        });
    }
    getMemberships() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`${this._apiurl}/memberships`);
        });
    }
    getVaults() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`${this._apiurl}/vaults`);
        });
    }
    getMembershipKeys() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.public(true).get(`${this._apiurl}/vaults/${this._vaultId}/keys`);
        });
    }
    getNodesByVaultId() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.public(true).get(`${this._apiurl}/vaults/${this._vaultId}/nodes`);
        });
    }
    getMembershipsByVaultId() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`${this._apiurl}/vaults/${this._vaultId}/memberships`);
        });
    }
    getNode() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.public(true).get(`${this._apiurl}/nodes/${this._resourceId}`);
        });
    }
    getMembership() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`${this._apiurl}/memberships/${this._resourceId}`);
        });
    }
    getVault() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.public(true).get(`${this._apiurl}/vaults/${this._resourceId}`);
        });
    }
    getTransactions() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`${this._apiurl}/vaults/${this._vaultId}/transactions`);
        });
    }
    patchNotifications() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.patch(`${this._apiurl}/notifications`);
        });
    }
    invite() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.post(`${this._apiurl}/vaults/${this._vaultId}/members`);
            return response.id;
        });
    }
    inviteResend() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.post(`${this._apiurl}/vaults/${this._vaultId}/members/${this._resourceId}`);
            return response.id;
        });
    }
    revokeInvite() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.delete(`${this._apiurl}/vaults/${this._vaultId}/members/${this._resourceId}`);
            return response.id;
        });
    }
    post(url) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.fetch("post", url);
        });
    }
    patch(url) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.fetch("patch", url);
        });
    }
    get(url) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.fetch("get", url);
        });
    }
    delete(url) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.fetch("delete", url);
        });
    }
    fetch(method, url) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const auth = yield akord_auth_1.Auth.getAuthorization();
            if (!auth && !this._isPublic) {
                throw new unauthorized_1.Unauthorized("Authentication is required to use Akord API");
            }
            const config = {
                method,
                url: this._queryParams ? this.addQueryParams(url, this._queryParams) : url,
                headers: {
                    'Authorization': auth,
                    'Content-Type': 'application/json'
                }
            };
            if (this._data) {
                config.data = this._data;
            }
            if (this._tags) {
                config.headers['x-amz-meta-tags'] = JSON.stringify(this._tags);
            }
            try {
                const response = yield (0, axios_1.default)(config);
                if ((0, paginated_1.isPaginated)(response)) {
                    return { items: response.data, nextToken: (0, paginated_1.nextToken)(response) };
                }
                return response.data;
            }
            catch (error) {
                (0, error_factory_1.throwError)((_a = error.response) === null || _a === void 0 ? void 0 : _a.status, (_c = (_b = error.response) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c.msg, error);
            }
        });
    }
    /**
     *
     * @requires:
     * - auth()
     * - vaultId()
     * - data()
     */
    transaction() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._input) {
                throw new bad_request_1.BadRequest("Input is required to use /transactions endpoint");
            }
            if (!this._tags) {
                throw new bad_request_1.BadRequest("Tags is required to use /transactions endpoint");
            }
            this.data({
                input: this._input,
                tags: this._tags,
                metadata: this._metadata
            });
            const response = yield this.post(`${this._apiurl}/vaults/${this._vaultId}/transactions`);
            return response;
        });
    }
    /**
     * Schedules transaction posting
     * @requires:
     * - auth()
     * - resourceId()
     * @uses:
     * - tags()
     */
    asyncTransaction() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._resourceId) {
                throw new bad_request_1.BadRequest("Resource id is required to use /transactions/files endpoint");
            }
            this.data({
                resourceUrl: this._resourceId,
                tags: this._tags,
                async: true,
                numberOfChunks: this._numberOfChunks
            });
            yield this.post(`${this._apiurl}/${this._transactionUri}/files`);
        });
    }
    /**
     *
     * @requires:
     * - auth()
     * - data()
     */
    uploadState() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.post(`${this._apiurl}/states`);
            return response.id;
        });
    }
    /**
     *
     * @requires:
     * - auth()
     * - data()
     * @uses:
     * - tags()
     * - resourceId()
     */
    uploadFile() {
        return __awaiter(this, void 0, void 0, function* () {
            this._dir = this._filesDir;
            yield this.upload();
            const resourceId = this._resourceId;
            const resourceTx = !this._cacheOnly ? yield this.fileTransaction() : null;
            return { resourceUrl: resourceId, id: resourceTx, resourceTx: resourceTx };
        });
    }
    /**
     *
     * @requires:
     * - auth()
     * - resourceId()
     */
    downloadFile() {
        return __awaiter(this, void 0, void 0, function* () {
            this._dir = this._filesDir;
            return yield this.download();
        });
    }
    /**
  *
  * @requires:
  * - auth()
  * - resourceId()
  */
    downloadState() {
        return __awaiter(this, void 0, void 0, function* () {
            this._dir = this._stateDir;
            return yield this.download();
        });
    }
    /**
    * Creates data item from uploaded resource. Schedules bundled transaction
    * @requires:
    * - auth()
    * - resourceId()
    * @uses:
    * - tags()
    */
    fileTransaction() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._resourceId) {
                this._resourceId = (0, uuid_1.v4)();
            }
            this.data({
                resourceUrl: this._resourceId,
                tags: this._tags
            });
            const response = yield this.post(`${this._apiurl}/${this._transactionUri}/files`);
            return response.txId;
        });
    }
    upload() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const auth = yield akord_auth_1.Auth.getAuthorization();
            if (!auth) {
                throw new unauthorized_1.Unauthorized("Authentication is required to use Akord API");
            }
            if (!this._data) {
                throw new bad_request_1.BadRequest('Missing data to upload. Use ApiClient#data() to add it');
            }
            if (!this._resourceId) {
                this._resourceId = this._isPublic ? this._publicDataDir + '/' + (0, uuid_1.v4)() : (0, uuid_1.v4)();
            }
            const me = this;
            const config = {
                method: 'put',
                url: `${this._storageurl}/${this._dir}/${this._resourceId}`,
                data: this._data,
                headers: {
                    'Authorization': auth,
                    'Content-Type': 'application/octet-stream'
                },
                signal: this._cancelHook ? this._cancelHook.signal : null,
                onUploadProgress(progressEvent) {
                    if (me._progressHook) {
                        let progress;
                        if (me._total) {
                            progress = Math.round((me._processed + progressEvent.loaded) / me._total * 100);
                        }
                        else {
                            progress = Math.round(progressEvent.loaded / progressEvent.total * 100);
                        }
                        me._progressHook(progress, { id: me._resourceId, total: progressEvent.total });
                    }
                }
            };
            if (this._cacheOnly) {
                config.headers['x-amz-meta-skipbundle'] = "true";
            }
            if (this._tags) {
                for (let tag of this._tags) {
                    // TODO: move it into the API
                    // ensure S3 backward compatibility
                    if (tag.name === "Encrypted-Key") {
                        config.headers['x-amz-meta-encryptedkey'] = tag.value;
                    }
                    else if (tag.name === "Initialization-Vector") {
                        config.headers['x-amz-meta-iv'] = tag.value;
                    }
                }
                config.headers['x-amz-meta-tags'] = JSON.stringify(this._tags);
            }
            try {
                const response = yield (0, axios_1.default)(config);
                return { resourceUrl: this._resourceId, resourceTx: response.data.resourceTx };
            }
            catch (error) {
                (0, error_factory_1.throwError)((_a = error.response) === null || _a === void 0 ? void 0 : _a.status, (_c = (_b = error.response) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c.msg, error);
            }
        });
    }
    download() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const auth = yield akord_auth_1.Auth.getAuthorization();
            if (!auth && !this._isPublic) {
                throw new unauthorized_1.Unauthorized("Authentication is required to use Akord API");
            }
            if (!this._resourceId) {
                throw new bad_request_1.BadRequest('Missing resource id to download');
            }
            const me = this;
            const config = {
                method: 'get',
                url: `${this._storageurl}/${this._dir}/${this._resourceId}`,
                responseType: this._responseType,
                signal: this._cancelHook ? this._cancelHook.signal : null,
                onDownloadProgress(progressEvent) {
                    if (me._progressHook) {
                        let progress;
                        if (me._total) {
                            const chunkSize = me._total / me._numberOfChunks;
                            progress = Math.round(me._processed / me._total * 100 + progressEvent.loaded / progressEvent.total * chunkSize / me._total * 100);
                        }
                        else {
                            progress = Math.round(progressEvent.loaded / progressEvent.total * 100);
                        }
                        me._progressHook(progress, { id: me._resourceId, total: progressEvent.total });
                    }
                },
            };
            if (!this._isPublic) {
                config.headers = {
                    'Authorization': auth,
                };
            }
            try {
                const response = yield (0, axios_1.default)(config);
                return { resourceUrl: this._resourceId, response: response };
            }
            catch (error) {
                (0, error_factory_1.throwError)((_a = error.response) === null || _a === void 0 ? void 0 : _a.status, (_c = (_b = error.response) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c.msg, error);
            }
        });
    }
}
exports.ApiClient = ApiClient;
