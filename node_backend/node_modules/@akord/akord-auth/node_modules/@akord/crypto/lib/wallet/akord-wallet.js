"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AkordWallet = void 0;
const keystore_1 = __importDefault(require("../storage/keystore"));
const bip39 = __importStar(require("bip39"));
const hdkey_1 = require("ethereum-cryptography/hdkey");
const encoding_1 = require("../encoding");
const functions_1 = require("../functions");
const libsodium_wrappers_1 = require("libsodium-wrappers");
const tweetnacl_1 = __importDefault(require("tweetnacl"));
// import { HDKeyT } from 'ethereum-cryptography/pure/hdkey'
const nodeCrypto = __importStar(require("crypto"));
const crypto = typeof window === 'undefined' ? nodeCrypto.webcrypto : window.crypto;
const HD_SIGNING_PATH = 'm/0\'/0\'/0';
const HD_ENCRYPTION_PATH = 'm/1\'/0\'/0';
const SALT_LENGTH = 16;
class AkordWallet {
    constructor(backupPhrase, encBackupPhrase) {
        this.backupPhrase = backupPhrase;
        this.encBackupPhrase = encBackupPhrase;
        this.keyPair = {
            privateKey: null,
            publicKey: null
        };
        this.signingKeyPair = {
            privateKey: null,
            publicKey: null
        };
    }
    encrypt(input) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, functions_1.encryptRawWithPublicKey)(this.publicKeyRaw(), input);
        });
    }
    decrypt(input) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, functions_1.decryptRawWithPrivateKey)(this.privateKeyRaw(), input);
        });
    }
    encryptToPublicKey(input, publicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, functions_1.encryptRawWithPublicKey)(publicKey, input);
        });
    }
    sign(string) {
        return __awaiter(this, void 0, void 0, function* () {
            const signingKey = this.signingPrivateKeyRaw();
            return (0, functions_1.signString)(string, signingKey);
        });
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            const signingPublicKey = this.signingPublicKeyRaw();
            return (0, functions_1.deriveAddress)(signingPublicKey);
        });
    }
    /**
     * Create the wallet
     * - generate 12 word backup phrase
     * - encrypt backup phrase with password derived symmetric key
     * - derive wallet keys from backup phrase
     * @param {string} password
     * @returns {Promise.<AkordWallet>} Promise of AkordWallet object
     */
    static create(password) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!password)
                throw new Error('Akord Wallet error: The password cannot be null.');
            const backupPhrase = bip39.generateMnemonic();
            const encBackupPhrase = yield encryptWithPassword(password, backupPhrase);
            const akordWallet = new AkordWallet(backupPhrase, encBackupPhrase);
            yield akordWallet.deriveKeys();
            return akordWallet;
        });
    }
    /**
     * Import the wallet from the encrypted backup phrase
     * - decrypt the encrypted backup phrase with password derived symmetric key
     * - derive wallet keys from backup phrase
     * @param {string} password
     * @param {string} encBackupPhrase
     * @returns {Promise.<AkordWallet>} Promise of AkordWallet object
     */
    static importFromEncBackupPhrase(password, encBackupPhrase) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!password)
                throw new Error('Akord Wallet error: The password cannot be null.');
            if (!encBackupPhrase)
                throw new Error('Akord Wallet error: The encrypted backup phrase cannot be null.');
            const backupPhrase = yield decryptWithPassword(password, encBackupPhrase);
            if (!this.isValidMnemonic(backupPhrase))
                throw new Error('Akord Wallet error: Invalid backup phrase.');
            const akordWallet = new AkordWallet(backupPhrase, encBackupPhrase);
            yield akordWallet.deriveKeys();
            return akordWallet;
        });
    }
    /**
   * Import the wallet from the backup phrase
   * - derive wallet keys from backup phrase
   * @param {string} password
   * @param {string} encBackupPhrase
   * @returns {Promise.<AkordWallet>} Promise of AkordWallet object
   */
    static importFromBackupPhrase(backupPhrase) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!backupPhrase)
                throw new Error('Akord Wallet error: The encrypted backup phrase cannot be null.');
            if (!this.isValidMnemonic(backupPhrase))
                throw new Error('Akord Wallet error: Invalid backup phrase.');
            const akordWallet = new AkordWallet(backupPhrase);
            yield akordWallet.deriveKeys();
            return akordWallet;
        });
    }
    /**
     * Import the wallet from the keystore
     * - retrieve the password derived symmetric key from the keystore
     * - retrieve the encrypted backup phrase from the local storage
     * -
     * @param {string} encBackupPhrase
     * @returns {Promise.<AkordWallet>} Promise of AkordWallet object
     */
    static importFromKeystore(encBackupPhrase) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!encBackupPhrase) {
                throw new Error('Akord Wallet error: The encrypted backup phrase cannot be null.');
            }
            const keystore = yield keystore_1.default.instance();
            const passwordKey = yield keystore.get('passwordKey');
            if (!passwordKey)
                throw new Error('Akord Wallet error: The password key cannot be null.');
            const parsedEncBackupPhrase = (0, encoding_1.base64ToJson)(encBackupPhrase);
            const plaintext = yield (0, functions_1.decrypt)(parsedEncBackupPhrase.encryptedPayload, passwordKey);
            const backupPhrase = (0, encoding_1.arrayToString)(plaintext);
            if (!this.isValidMnemonic(backupPhrase))
                throw new Error('Akord Wallet error: Invalid backup phrase.');
            const akordWallet = new AkordWallet(backupPhrase, encBackupPhrase);
            yield akordWallet.deriveKeys();
            return akordWallet;
        });
    }
    /**
     * Import the wallet from the backup phrase
     * - encrypt backup phrase with new password derived symmetric key
     * - derive wallet keys from backup phrase
     * @param {string} newPassword
     * @param {string} backupPhrase
     * @returns {Promise.<AkordWallet>} Promise of AkordWallet object
     */
    static recover(newPassword, backupPhrase) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isValidMnemonic(backupPhrase))
                throw new Error('Akord Wallet error: Invalid backup phrase.');
            const encBackupPhrase = yield encryptWithPassword(newPassword, backupPhrase);
            const akordWallet = new AkordWallet(backupPhrase, encBackupPhrase);
            yield akordWallet.deriveKeys();
            return akordWallet;
        });
    }
    static changePassword(oldPassword, newPassword, encBackupPhrase) {
        return __awaiter(this, void 0, void 0, function* () {
            // decrypt backup phrase with the old password
            const backupPhrase = yield decryptWithPassword(oldPassword, encBackupPhrase);
            if (!this.isValidMnemonic(backupPhrase))
                throw new Error('Akord Wallet error: Invalid backup phrase.');
            // encrypt backup phrase with the new password
            const newEncBackupPhrase = yield encryptWithPassword(newPassword, backupPhrase);
            const akordWallet = new AkordWallet(backupPhrase, newEncBackupPhrase);
            yield akordWallet.deriveKeys();
            return akordWallet;
        });
    }
    static clear() {
        return __awaiter(this, void 0, void 0, function* () {
            const keystore = yield keystore_1.default.instance();
            yield keystore.delete('passwordKey');
        });
    }
    static isValidMnemonic(backupPhrase) {
        return bip39.validateMnemonic(backupPhrase);
    }
    /**
     * Root node derivation from backup phrase
     * - derives the master seed from the backup phrase
     * - derives the root node from the master seed
     * @returns {Promise.<hdkey>} Promise of hdkey object with HD wallet root node
     */
    getRoot() {
        return __awaiter(this, void 0, void 0, function* () {
            const seed = yield bip39.mnemonicToSeed(this.backupPhrase);
            return hdkey_1.HDKey.fromMasterSeed(seed);
        });
    }
    /**
     * Node derivation from backup phrase and given path
     * @param {string} path
     * @returns {Promise.<hdkey>} Promise of hdkey object with HD wallet node
     */
    getNodeFromPath(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const root = yield this.getRoot();
            return root.derive(path);
        });
    }
    /**
     * Public key derivation for the given path
     * @param {string} path
     * @returns {Promise.<string>} Promise of base64 string represents public key
     */
    getPublicKeyFromPath(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const keyPair = yield this.getKeyPairFromPath(path);
            return keyPair.publicKey;
        });
    }
    /**
     * Private key derivation for the given path
     * @param {string} path
     * @returns {Promise.<string>} Promise of base64 string represents private key
     */
    getPrivateKeyFromPath(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const keyPair = yield this.getKeyPairFromPath(path);
            return keyPair.privateKey;
        });
    }
    /**
     * Key pair derivation for the given path
     * @param {string} path
     * @returns {Promise.<{ publicKey: string, privateKey: string }>} Promise of JSON represents key pair
     */
    getKeyPairFromPath(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const node = yield this.getNodeFromPath(path);
            yield libsodium_wrappers_1.ready;
            if (path === HD_ENCRYPTION_PATH) {
                const encryptionKeyPair = tweetnacl_1.default.box.keyPair.fromSecretKey(node.privateKey);
                return {
                    publicKey: (0, encoding_1.arrayToBase64)(encryptionKeyPair.publicKey),
                    privateKey: (0, encoding_1.arrayToBase64)(encryptionKeyPair.secretKey)
                };
            }
            const signingKeyPair = (0, libsodium_wrappers_1.crypto_sign_seed_keypair)(node.privateKey);
            return {
                publicKey: (0, encoding_1.arrayToBase64)(signingKeyPair.publicKey),
                privateKey: (0, encoding_1.arrayToBase64)(signingKeyPair.privateKey)
            };
        });
    }
    /**
     * Derive encryption and signing key pair for the wallet
     */
    deriveKeys() {
        return __awaiter(this, void 0, void 0, function* () {
            const node = yield this.getNodeFromPath(HD_ENCRYPTION_PATH);
            const signingNode = yield this.getNodeFromPath(HD_SIGNING_PATH);
            yield libsodium_wrappers_1.ready;
            const encryptionKeyPair = tweetnacl_1.default.box.keyPair.fromSecretKey(node.privateKey);
            const signingKeyPair = (0, libsodium_wrappers_1.crypto_sign_seed_keypair)(signingNode.privateKey);
            this.keyPair.privateKey = encryptionKeyPair.secretKey;
            this.keyPair.publicKey = encryptionKeyPair.publicKey;
            this.signingKeyPair.privateKey = signingKeyPair.privateKey;
            this.signingKeyPair.publicKey = signingKeyPair.publicKey;
        });
    }
    /**
     * Encryption private key
     * @returns {Uint8Array}
     */
    privateKeyRaw() {
        return this.keyPair.privateKey;
    }
    /**
     * Encryption public key
     * @returns {Uint8Array}
     */
    publicKeyRaw() {
        return this.keyPair.publicKey;
    }
    /**
     * Encryption private key as a string
     * @returns {string}
     */
    privateKey() {
        return (0, encoding_1.arrayToBase64)(this.keyPair.privateKey);
    }
    /**
     * Encryption public key as a string
     * @returns {string}
     */
    publicKey() {
        return (0, encoding_1.arrayToBase64)(this.keyPair.publicKey);
    }
    /**
     * Signing private key
     * @returns {Uint8Array}
     */
    signingPrivateKeyRaw() {
        return this.signingKeyPair.privateKey;
    }
    /**
     * Signing public key
     * @returns {Uint8Array}
     */
    signingPublicKeyRaw() {
        return this.signingKeyPair.publicKey;
    }
    /**
     * Signing private key as a string
     * @returns {string}
     */
    signingPrivateKey() {
        return (0, encoding_1.arrayToBase64)(this.signingKeyPair.privateKey);
    }
    /**
     * Signing public key as a string
     * @returns {string}
     */
    signingPublicKey() {
        return (0, encoding_1.arrayToBase64)(this.signingKeyPair.publicKey);
    }
}
exports.AkordWallet = AkordWallet;
/**
 * Encryption with key derived from password
 * - generate random salt
 * - derive the encryption key from password and salt
 * - encrypt plaintext with the derived key
 * @param {string} password
 * @param {string} plaintext utf-8 string plaintext
 * @returns {Promise.<string>} Promise of string represents stringified payload
 */
function encryptWithPassword(password, plaintext) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const salt = crypto.getRandomValues(new Uint8Array(SALT_LENGTH));
            const derivedKey = yield (0, functions_1.deriveKey)(password, salt);
            const keystore = yield keystore_1.default.instance();
            yield keystore.store('passwordKey', derivedKey);
            const encryptedPayload = yield (0, functions_1.encrypt)((0, encoding_1.stringToArray)(plaintext), derivedKey);
            const payload = {
                encryptedPayload: encryptedPayload,
                salt: (0, encoding_1.arrayToBase64)(salt)
            };
            return (0, encoding_1.jsonToBase64)(payload);
        }
        catch (err) {
            throw new Error('Akord Wallet error: encrypt with password: ' + err);
        }
    });
}
/**
 * Decryption with key derived from password
 * - parse the payload
 * - derive the decryption key from password and salt
 * - decrypt the ciphertext with the derived key
 * @param {string} password
 * @param {string} strPayload stringified payload
 * @returns {Promise.<string>} Promise of string represents utf-8 plaintext
 */
function decryptWithPassword(password, strPayload) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const parsedPayload = (0, encoding_1.base64ToJson)(strPayload);
            const encryptedPayload = parsedPayload.encryptedPayload;
            const salt = (0, encoding_1.base64ToArray)(parsedPayload.salt);
            const derivedKey = yield (0, functions_1.deriveKey)(password, salt);
            const keystore = yield keystore_1.default.instance();
            yield keystore.store('passwordKey', derivedKey);
            const plaintext = yield (0, functions_1.decrypt)(encryptedPayload, derivedKey);
            return (0, encoding_1.arrayToString)(plaintext);
        }
        catch (err) {
            throw new Error('Akord Wallet error: decrypt with password: ' + err);
        }
    });
}
//# sourceMappingURL=akord-wallet.js.map