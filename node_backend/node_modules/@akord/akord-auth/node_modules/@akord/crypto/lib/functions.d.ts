import { KeyPair } from 'libsodium-wrappers';
import { EncryptedData, EncryptedPayload } from './types';
/**
 * Export CryptoKey object to base64 encoded string
 * @param {CryptoKey} key
 * @returns {Promise.<string>} string containing crypto key
 */
declare function exportKeyToBase64(key: CryptoKey): Promise<string>;
/**
 * Import CryptoKey object from base64 encoded string
 * @param {string} keyBase64
 * @returns {Promise.<CryptoKey>} crypto key object
 */
declare function importKeyFromBase64(keyBase64: string): Promise<CryptoKey>;
/**
 * Import key from a random seed
 * @param {Uint8Array} key
 * @returns {Promise.<CryptoKey>} crypto key object
 */
declare function importKeyFromSeed(seed: Uint8Array): Promise<CryptoKey>;
/**
 * Signature generation using sodium library: https://github.com/jedisct1/libsodium
 * @param {BufferSource} msgHash buffer message hash to be signed
 * @param {Uint8Array} privateKey private key used to sign message hash
 * @returns {Promise.<string>} signature as base64 string
 */
declare function signHash(msgHash: ArrayBuffer, privateKey: Uint8Array): Promise<string>;
/**
 * Digest generation
 * @param {string} payload string payload to be signed
 * @returns {Promise.<string>} payload digest as base64 string
 */
declare function digest(payload: string): Promise<string>;
declare function digestRaw(payload: Uint8Array): Promise<string>;
/**
 * Signature generation
 * @param {string} payload string payload to be signed
 * @param {Uint8Array} privateKey private key used to sign string payload
 * @returns {Promise.<string>} signature as base64 string
 */
declare function signString(payload: string, privateKey: Uint8Array): Promise<string>;
/**
 * Encryption using WebCrypto
 * - generate a random initialization vector (iv)
 * - encrypt plaintext using key and iv
 * @param {Uint8Array} plaintext
 * @param {CryptoKey} key
 * @returns {Promise.<string>} Promise of base64 string represents the ciphertext along with iv
 */
declare function encrypt(plaintext: Uint8Array, key: CryptoKey, encode?: boolean): Promise<string | EncryptedData>;
/**
 * Decryption using WebCrypto
 * - decrypt ciphertext using key and iv
 * @param {Object} encryptedPayload
 * @param {CryptoKey} key
 * @returns {Promise.<ArrayBuffer>} Promise of ArrayBuffer represents the plaintext
 */
declare function decrypt(encryptedPayload: string | EncryptedData, key: CryptoKey, decode?: boolean): Promise<ArrayBuffer>;
/**
 * Key derivation using WebCrypto
 * - PBKDF2 with 150000 iterations of SHA-256
 * @param {string} password
 * @param {BufferSource} salt
 * @returns {Promise.<CryptoKey>} Promise of CryptoKey object with AES 256-bit symmetric key
 */
declare function deriveKey(password: string, salt: Uint8Array): Promise<CryptoKey>;
/**
 * Symmetric key generation
 * - generate an extractable AES 256-bit symmetric key
 * @returns {Promise.<CryptoKey>}
 */
declare function generateKey(): Promise<CryptoKey>;
/**
 * Public key pair generation
 * - generate a Curve25519 key pair
 * @returns {Promise.<_sodium.KeyPair>}
 */
declare function generateKeyPair(): Promise<KeyPair>;
declare function deriveAddress(publicKey: Uint8Array): Promise<string>;
/**
 * Encryption using sodium library: https://github.com/jedisct1/libsodium
 * @param {Uint8Array} publicKey public key used to encrypt the data
 * @param {Uint8Array} plaintext raw plaintext byte array
 * @returns {Promise.<string>} Promise of base64 string represents the encrypted payload
 */
declare function encryptRawWithPublicKey(publicKey: Uint8Array, plaintext: string | Uint8Array): Promise<string>;
/**
 * Decryption using sodium library: https://github.com/jedisct1/libsodium
 * @param {Uint8Array} privateKey private key used to decrypt the data
 * @param {string} encryptedPayload base64 string represents the encrypted payload
 * @returns {Promise.<Uint8Array>} Promise of raw plaintext byte array
 */
declare function decryptRawWithPrivateKey(privateKey: Uint8Array, encryptedPayload: string): Promise<Uint8Array>;
declare function encryptStringWithPublicKey(publicKey: Uint8Array, plaintext: string): Promise<string>;
declare function decryptStringWithPrivateKey(privateKey: Uint8Array, encryptedPayload: string): Promise<string>;
/**
 * CryptoKey object decryption
 * - decrypts encoded key string with the given private key
 * - import CryptoKey object from the encoded string
 * @param {string} encryptedKey
 * @param {Uint8Array} privateKey
 * @returns {Promise.<CryptoKey>}
 */
declare function decryptKeyWithPrivateKey(encryptedKey: string, privateKey: Uint8Array): Promise<CryptoKey>;
/**
 * Hybrid encryption
 * - generate a symmetric access key
 * - encrypt data with the access key
 * - encrypt the access key with the public key
 * @param {Uint8Array} plaintext raw plaintext byte array
 * @param {Uint8Array} publicKey public key used to encrypt the data
 * @returns {Promise.<Uint8Array>} Promise of raw plaintext byte array
 */
declare function encryptHybridRaw(plaintext: Uint8Array, publicKey: Uint8Array, encode?: boolean, accessKey?: CryptoKey): Promise<string | EncryptedPayload>;
declare function encryptHybridString(plaintext: string, publicKey: Uint8Array): Promise<string | EncryptedPayload>;
/**
 * Hybrid decryption
 * - decrypt the access key with the private key
 * - decrypt the data with the access key
 * @param {string} encryptedPayload base64 string represents the encrypted payload
 * @param {Uint8Array} privateKey private key used to decrypt the data key
 * @returns {Promise.<ArrayBuffer>} Promise of raw plaintext byte array
 */
declare function decryptHybridRaw(encryptedPayload: string | EncryptedPayload, privateKey: Uint8Array, decode?: boolean): Promise<ArrayBuffer>;
declare function decryptHybridString(encryptedPayload: string, privateKey: Uint8Array): Promise<string>;
/**
 * Derive two passwords from input password
 * @param {string} password
 * @returns {Promise.<{string, string}>} Promise of derived passwords
 */
declare function derivePasswords(password: string): Promise<{
    authPassword: string;
    walletPassword: string;
}>;
declare const importRSAPublicKey: (publicKey: string) => Promise<CryptoKey>;
declare const importRSACryptoKey: (jwk: JsonWebKey) => Promise<CryptoKey>;
export { exportKeyToBase64, importKeyFromBase64, importKeyFromSeed, importRSAPublicKey, digest, digestRaw, signHash, signString, encrypt, decrypt, deriveKey, generateKey, generateKeyPair, encryptRawWithPublicKey, decryptRawWithPrivateKey, encryptStringWithPublicKey, decryptStringWithPrivateKey, decryptKeyWithPrivateKey, encryptHybridRaw, encryptHybridString, decryptHybridRaw, decryptHybridString, derivePasswords, deriveAddress, importRSACryptoKey };
