"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encrypted = exports.Encryptable = void 0;
require("reflect-metadata");
const crypto_1 = require("../crypto");
class Encryptable {
    constructor(keys, publicKey) {
        this.__keys__ = keys;
        this.__publicKey__ = publicKey;
    }
    decrypt() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.__encryptProps__) {
                crypto_1.Crypto.encrypter().setKeys(this.__keys__);
                yield Promise.all(Array.from(this.__encryptProps__.values()).map((prop) => __awaiter(this, void 0, void 0, function* () {
                    if (!this[prop]) {
                        return this[prop];
                    }
                    const decrypted = yield crypto_1.Crypto.decrypt(this[prop]);
                    this[prop] = decrypted;
                    return decrypted;
                })));
            }
            yield Promise.all(Object.keys(this).map((prop) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                if (this[prop]) {
                    if (((_a = Object.getPrototypeOf(Object.getPrototypeOf(this[prop]))) === null || _a === void 0 ? void 0 : _a.constructor) === Encryptable) {
                        yield this[prop].decrypt();
                    }
                    else if (Array.isArray(this[prop])) {
                        yield Promise.all(this[prop].map((el) => __awaiter(this, void 0, void 0, function* () {
                            var _b;
                            if (el && ((_b = Object.getPrototypeOf(Object.getPrototypeOf(el))) === null || _b === void 0 ? void 0 : _b.constructor) === Encryptable)
                                yield el.decrypt();
                        })));
                    }
                }
            })));
            return Promise.resolve();
        });
    }
    encrypt() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.__encryptProps__) {
                crypto_1.Crypto.encrypter().setKeys(this.__keys__);
                crypto_1.Crypto.encrypter().setPublicKey(this.__publicKey__);
                yield Promise.all(Array.from(this.__encryptProps__.values()).map((prop) => __awaiter(this, void 0, void 0, function* () {
                    if (!this[prop]) {
                        return this[prop];
                    }
                    const encrypt = yield crypto_1.Crypto.encrypt(this[prop]);
                    this[prop] = encrypt;
                    return encrypt;
                })));
            }
            yield Promise.all(Object.keys(this).map((prop) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                if (this[prop]) {
                    if (((_a = Object.getPrototypeOf(Object.getPrototypeOf(this[prop]))) === null || _a === void 0 ? void 0 : _a.constructor) === Encryptable) {
                        yield this[prop].decrypt();
                    }
                    else if (Array.isArray(this[prop])) {
                        yield Promise.all(this[prop].map((el) => __awaiter(this, void 0, void 0, function* () {
                            var _b;
                            if (el && ((_b = Object.getPrototypeOf(Object.getPrototypeOf(el))) === null || _b === void 0 ? void 0 : _b.constructor) === Encryptable)
                                yield el.encrypt();
                        })));
                    }
                }
            })));
            return Promise.resolve();
        });
    }
}
exports.Encryptable = Encryptable;
/**
 *
 * De/-Encrypt class attribute(s).
 * @example
```
class Foo extends Encryptable {
    constructor(bar, _keys) {
        super(_keys)
        this.bar = bar
    }

    @encrypted()
    bar: string // attr will be de/-encrypted
}
const foo = new Foo("test")
await foo.encrypt()
await foo.decrypt()
```
 */
function encrypted() {
    return function (target, propertyKey) {
        if (!target.__encryptProps__) {
            target.__encryptProps__ = new Set();
        }
        target.__encryptProps__.add(propertyKey);
    };
}
exports.encrypted = encrypted;
//# sourceMappingURL=encrypt.js.map