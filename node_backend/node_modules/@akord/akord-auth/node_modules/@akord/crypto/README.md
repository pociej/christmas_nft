# @akord/crypto
In browser en-/decryption API

Module is helping in bringing the client apps into end-2-end encrypted, privacy-first world. No reinventig APIs, just facading well known libs to make those more developer friendly for majority of business cases.

## e2e encryption

See [here](https://docs.akord.com/learn/end-to-end-encryption) to learn more about e2e encryption @Akord

## Installation
```
npm i @akord/crypto
```
## Usage

1. Configure the module:

- for a new user - create wallet based on password (creates new wallet and backup phrase)
```javascript
        Crypto.configure(
            { 
                password: "test"
            }
        )
```

- for existing user with password adn backup phrase
```javascript
        Crypto.configure(
            { 
                password: "test",
                encBackupPhrase: "yExlksth..."
            }
        )
```

2. Use public api of the module to de/-encrypt:
- decorators
- functions


### Decorators

Decorators are a way to go to abstract encryption from business logic. The goal of decorators API is really to "decorate" client side app with encryption

Use two high-level functions (encrypt & decrypt) as decorators like:

```javascript
class User extends Encryptable {
    @encrypted()
    name: string;
    
    @encrypted()
    profileImageUrl: string;

    id: string

    constructor(name: string, profileImageUrl: string, keys: Array<Keys>, publicKey: string) {
        super(keys, publicKey);
        this.name = name;
        this.profileImageUrl = profileImageUrl;
    }    
}
const user = new User("yExlksth...", "https:/profile-image...", [{encPrivateKey: "yJbmdor...", publicKey: "yHklouu.." }], "yHuyks...")
await user.encrypt()
```
Same rules apply to methods and their parameters

```javascript
    saveFooBar(
        @encrypted foo: string, 
        bar: string) {
        ...
    }
```
In the above `foo` param will be end up as encrypted string in method body. `bar` param will stay untouched.

Complex structures are supported:
```javascript
    saveFooBar(
        @encrypted(attributes="encAttr1,encAttr2") foo: Foo, 
        bar: string) {
        ...
    }

    Foo {
        id: string
        encAttr1: string
        encAttr2: string
    }
```

and decryption goes like

```javascript
class User extends Encryptable {
    
    @encrypted()
    name: string;
    
    @encrypted()
    profileImageUrl: string;

    id: string

    constructor(name: string, profileImageUrl: string, keys: Array<Keys>){
        this.name = name;
        this.profileImageUrl = profileImageUrl;
    }    
}

const user = new User("yExlksth...", [{encPrivateKey: "yJbmdor...", publicKey: "yHklouu.." }])
await user.decrypt()
```

```javascript
    fetchBar(
        @decrypted param1: string,
        param2: HeaderParams
        ) {
        ...
    }
```
in the above `param1` will be decreypted, param2 will not be touched.
No need to refactor the code to split complex parameters into single string params:
```javascript
    fetchBar(
        @decrypted(attributes="encAttr1,encAttr2") param1: QueryParams,
        param2: HeaderParams
        ) {
        ...
    }

    QueryParams {
        id: string
        encAttr1: string
        encAttr2: string
    }
```
In the above `id` from `QueryParams` will not be decrypted. Obviously `HeaderParams` will also stay untouched


### Use as simple functions
...


### Development
```
yarn install
yarn build
```

To run all tests:
```
yarn test
```

To run single test file:
```
yarn test <path-to-test-file>

yarn test ./src/__tests__/encrypt.test.ts
```

To run single test file with direct log output:
```
node --inspect node_modules/.bin/jest ./src/__tests__/wallet.test.ts
```