"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Auth = void 0;
const crypto_1 = require("@akord/crypto");
const amazon_cognito_identity_js_1 = require("amazon-cognito-identity-js");
class Auth {
    constructor() { }
    static configure(options = defaultAuthOptions) {
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaultAuthOptions), this.options), options);
        this.options = optionsWithDefaults;
        this.config = apiConfig(optionsWithDefaults.env);
        if (optionsWithDefaults.authToken) {
            this.authToken = optionsWithDefaults.authToken;
        }
        else if (optionsWithDefaults.apiKey) {
            this.apiKey = optionsWithDefaults.apiKey;
        }
        else {
            this.storage = optionsWithDefaults.storage;
            this.pool = new amazon_cognito_identity_js_1.CognitoUserPool({
                UserPoolId: this.config.userPoolId,
                ClientId: this.config.userPoolsWebClientId,
                Storage: this.storage
            });
        }
    }
    static getCognitoUser(username) {
        const userData = {
            Username: username,
            Pool: this.pool,
            Storage: this.storage
        };
        const cognitoUser = new amazon_cognito_identity_js_1.CognitoUser(userData);
        return cognitoUser;
    }
    static jsonToUserAttributes(json) {
        const attributes = [];
        for (const [key, value] of Object.entries(json)) {
            attributes.push(new amazon_cognito_identity_js_1.CognitoUserAttribute({
                Name: key,
                Value: value
            }));
        }
        return attributes;
    }
}
exports.Auth = Auth;
Auth.options = {};
/**
* @param  {string} email
* @param  {string} password
* @returns Promise with AuthSession containing Akord Wallet and jwt token
*/
Auth.signIn = function (email, password) {
    return __awaiter(this, void 0, void 0, function* () {
        const { user, session } = yield Auth.authenticateUser(email, password);
        const attributes = yield Auth.retrieveUserAttributes(user);
        const wallet = yield crypto_1.AkordWallet.importFromEncBackupPhrase(password, attributes["custom:encBackupPhrase"]);
        return { wallet, jwt: session.getIdToken().getJwtToken() };
    });
};
/**
* @param  {string} wallet akord wallet instance
* @returns  Promise with AuthSession containing Akord Wallet and jwt token
*/
Auth.signInWithWallet = function (wallet) {
    return __awaiter(this, void 0, void 0, function* () {
        const address = yield wallet.getAddress();
        const username = address + "@temp.akord.com";
        const cognitoUser = Auth.getCognitoUser(username);
        const authenticationData = {
            Username: username
        };
        const privateKey = wallet.signingPrivateKeyRaw();
        const authenticationDetails = new amazon_cognito_identity_js_1.AuthenticationDetails(authenticationData);
        const { session } = yield new Promise((resolve, reject) => {
            cognitoUser.setAuthenticationFlowType("CUSTOM_AUTH");
            cognitoUser.initiateAuth(authenticationDetails, {
                onSuccess: function (result) {
                    resolve({ user: cognitoUser, session: result });
                },
                onFailure: function (err) {
                    return reject(err);
                },
                customChallenge: function (challengeParameters) {
                    return __awaiter(this, void 0, void 0, function* () {
                        const signature = yield (0, crypto_1.signString)(challengeParameters.nonce, privateKey);
                        cognitoUser.sendCustomChallengeAnswer(signature, this);
                    });
                },
            });
        });
        const jwt = session.getIdToken().getJwtToken();
        return { wallet, jwt };
    });
};
/**
 * @param  {string} confirmationCode
 * @param  {string} password
 * @param  {MfaType} mfaType
 * @returns Promise with AuthSession containing Akord Wallet and jwt token
*/
Auth.confirmSignIn = function (confirmationCode, password, mfaType) {
    return __awaiter(this, void 0, void 0, function* () {
        const { user, session } = yield Auth.confirmUser(confirmationCode, mfaType);
        const attributes = yield Auth.retrieveUserAttributes(user);
        const wallet = yield crypto_1.AkordWallet.importFromEncBackupPhrase(password, attributes["custom:encBackupPhrase"]);
        return { wallet, jwt: session.getIdToken().getJwtToken() };
    });
};
/**
* @returns Promise with AuthSession containing Akord Wallet and jwt token
*/
Auth.authenticate = function () {
    return __awaiter(this, void 0, void 0, function* () {
        const { session, user } = yield Auth.getCurrentSessionUser();
        const attributes = yield Auth.retrieveUserAttributes(user);
        const wallet = yield crypto_1.AkordWallet.importFromKeystore(attributes["custom:encBackupPhrase"]);
        return { wallet, jwt: session.getIdToken().getJwtToken() };
    });
};
Auth.signOut = function () {
    return __awaiter(this, void 0, void 0, function* () {
        const cognitoUser = this.pool.getCurrentUser();
        if (cognitoUser != null) {
            const session = yield new Promise((resolve, reject) => cognitoUser.getSession((err, session) => {
                if (err || !session) {
                    reject(err || new Error("Invalid session"));
                }
                resolve(session);
            }));
            session;
            cognitoUser.signOut();
        }
        ;
    });
};
/**
* @param  {string} email
* @param  {string} password
* @param  {SignUpOptions} options JSON client metadata, ex: { clientType: "CLI" }
* @returns Promise with Akord Wallet
*/
Auth.signUp = function (email, password, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        let wallet;
        if (options.wallet) {
            wallet = options.wallet;
        }
        else {
            wallet = yield crypto_1.AkordWallet.create(password);
        }
        const attributes = [];
        for (const [key, value] of Object.entries({
            email,
            "custom:encBackupPhrase": wallet.encBackupPhrase,
            "custom:publicKey": wallet.publicKey(),
            "custom:publicSigningKey": wallet.signingPublicKey(),
            "custom:address": yield wallet.getAddress(),
            "custom:referrerId": options.referrerId,
            "custom:mode": "dark",
            "custom:notifications": "true"
        })) {
            attributes.push(new amazon_cognito_identity_js_1.CognitoUserAttribute({
                Name: key,
                Value: value
            }));
        }
        yield new Promise((resolve, reject) => this.pool.signUp(email, password, attributes, null, (err, result) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(result);
            }
        }, { verifyUrl: options.verifyUrl, clientType: options.clientType }));
        return { wallet };
    });
};
/**
* @param  {AkordWallet} wallet akord wallet instance
* @param  {SignUpOptions} options JSON client metadata, ex: { clientType: "CLI" }
* @returns Promise with Akord Wallet
*/
Auth.signUpWithWallet = function (wallet, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const random = Math.random().toString(30);
        if (!wallet) {
            wallet = yield crypto_1.AkordWallet.create(random);
        }
        const address = yield wallet.getAddress();
        const attributes = Auth.jsonToUserAttributes({
            "custom:publicKey": wallet.publicKey(),
            "custom:publicSigningKey": wallet.signingPublicKey(),
            "custom:address": address,
            "custom:referrerId": options.referrerId,
            "custom:mode": "dark",
            "custom:notifications": "true",
            "custom:passwordless": "true"
        });
        yield new Promise((resolve, reject) => this.pool.signUp(address + "@temp.akord.com", random, attributes, null, (err, result) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(result);
            }
        }, { verifyUrl: options.verifyUrl, clientType: options.clientType }));
        return { wallet };
    });
};
Auth.resendCode = function (email, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const user = Auth.getCognitoUser(email);
        return new Promise((resolve, reject) => user.resendConfirmationCode((err, result) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(result);
            }
        }, { verifyUrl: options.verifyUrl, clientType: options.clientType }));
    });
};
/**
* @param  {string} email
* @param  {string} code
* @returns
*/
Auth.verifyAccount = function (email, code) {
    return __awaiter(this, void 0, void 0, function* () {
        const user = Auth.getCognitoUser(email);
        return new Promise((resolve, reject) => user.confirmRegistration(code, false, (err, result) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(result);
            }
        }));
    });
};
Auth.changePassword = function (currentPassword, newPassword) {
    return __awaiter(this, void 0, void 0, function* () {
        const { user } = yield Auth.getCurrentSessionUser();
        const attributes = yield Auth.retrieveUserAttributes(user);
        const encBackupPhrase = attributes['custom:encBackupPhrase'];
        const wallet = yield crypto_1.AkordWallet.changePassword(currentPassword, newPassword, encBackupPhrase);
        yield this.updateUserAttribute('custom:encBackupPhrase', wallet.encBackupPhrase);
        yield new Promise((resolve, reject) => user.changePassword(currentPassword, newPassword, (err, result) => {
            if (err) {
                reject(err);
            }
            resolve(result);
        }));
        const jwt = yield this.getAuthToken();
        return { wallet, jwt };
    });
};
Auth.changePasswordSubmit = function (email, code, password) {
    return __awaiter(this, void 0, void 0, function* () {
        const { user } = yield Auth.getCurrentSessionUser();
        yield new Promise((resolve, reject) => user.confirmPassword(code, password, {
            onSuccess() {
                resolve('password_changed');
            },
            onFailure(err) {
                reject(err);
            },
        }));
    });
};
Auth.forgotPassword = function (email, verifyUrl) {
    return __awaiter(this, void 0, void 0, function* () {
        const user = Auth.getCognitoUser(email);
        yield new Promise((resolve, reject) => user.forgotPassword({
            onSuccess() {
                resolve(user);
            },
            onFailure(err) {
                reject(err);
            },
        }, { resetPasswordUrl: verifyUrl }));
    });
};
Auth.forgotPasswordSubmit = function (email, code, backupPhrase, newPassword) {
    return __awaiter(this, void 0, void 0, function* () {
        const wallet = yield crypto_1.AkordWallet.recover(newPassword, backupPhrase);
        const user = Auth.getCognitoUser(email);
        yield new Promise((resolve, reject) => user.confirmPassword(code, newPassword, {
            onSuccess() {
                resolve(user);
            },
            onFailure(err) {
                reject(err);
            },
        }));
        yield Auth.authenticateUser(email, newPassword);
        yield Auth.updateUserAttribute("custom:encBackupPhrase", wallet.encBackupPhrase);
    });
};
/**
 * Gets jwt token if available. For SRP auth:
 * 1. Get idToken, accessToken, refreshToken, and clockDrift from storage
 * 2. Validate the tokens if active or expired.
 * 3. If tokens are valid, return current session.
 * 4. If tokens are expired, invoke the refreshToken().
 */
Auth.getAuthToken = function () {
    return __awaiter(this, void 0, void 0, function* () {
        if (this.authToken) {
            return this.authToken;
        }
        else if (this.apiKey) {
            return null;
        }
        else {
            const session = (yield Auth.getCurrentSessionUser()).session;
            if (!session) {
                return null;
            }
            return session.getIdToken().getJwtToken();
        }
    });
};
Auth.getAuthorization = function () {
    return __awaiter(this, void 0, void 0, function* () {
        if (this.apiKey) {
            return this.apiKey;
        }
        else {
            try {
                const token = yield this.getAuthToken();
                if (token) {
                    return `Bearer ${token}`;
                }
            }
            catch (e) {
                // not authorized
            }
        }
        return null;
    });
};
Auth.getUser = function (bypassCache) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const { user } = yield Auth.getCurrentSessionUser();
            return yield new Promise((resolve, reject) => user.getUserData((err, data) => {
                if (err) {
                    reject(err);
                }
                const { Username, PreferredMfaSetting, UserAttributes } = data;
                const attributes = UserAttributes.reduce(function (attributesObject, attribute) {
                    attributesObject[attribute.Name] = attribute.Value;
                    return attributesObject;
                }, {});
                let mfaType;
                if (attributes["custom:backupPhraseMFA"] === "true") {
                    mfaType = "BACKUP_PHRASE";
                }
                else if (PreferredMfaSetting === "SMS_MFA") {
                    mfaType = "SMS";
                }
                else if (PreferredMfaSetting === "SOFTWARE_TOKEN_MFA") {
                    mfaType = "TOTP";
                }
                resolve({ username: Username, mfaType: mfaType, attributes: attributes });
            }, { bypassCache: bypassCache = false }));
        }
        catch (e) {
            return null;
        }
    });
};
Auth.getUserAttributes = function () {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const { user } = yield Auth.getCurrentSessionUser();
            return yield Auth.retrieveUserAttributes(user);
        }
        catch (e) {
            return {};
        }
    });
};
Auth.updateUserAttribute = function (attributeName, attributeValue) {
    return __awaiter(this, void 0, void 0, function* () {
        const { user } = yield Auth.getCurrentSessionUser();
        const attributeList = [];
        const attribute = new amazon_cognito_identity_js_1.CognitoUserAttribute({
            Name: attributeName,
            Value: attributeValue,
        });
        attributeList.push(attribute);
        yield new Promise((resolve, reject) => user.updateAttributes(attributeList, function (err, result) {
            if (err) {
                reject(err);
            }
            resolve(result);
        }));
    });
};
Auth.enableMFA = function (mfaType) {
    return __awaiter(this, void 0, void 0, function* () {
        const { user } = yield Auth.getCurrentSessionUser();
        if (mfaType === "BACKUP_PHRASE") {
            yield this.updateUserAttribute("custom:backupPhraseMFA", "true");
        }
        else {
            const smsMfaSettings = {
                PreferredMfa: false,
                Enabled: false,
            };
            const totpMfaSettings = {
                PreferredMfa: false,
                Enabled: false,
            };
            if (mfaType === "SMS") {
                smsMfaSettings.PreferredMfa = true;
                smsMfaSettings.Enabled = true;
            }
            else if (mfaType === "TOTP") {
                totpMfaSettings.PreferredMfa = true;
                totpMfaSettings.Enabled = true;
            }
            ;
            yield new Promise((resolve, reject) => user.setUserMfaPreference(smsMfaSettings, totpMfaSettings, function (err, result) {
                if (err) {
                    reject(err);
                }
                resolve("mfa_enabled");
            }));
        }
    });
};
Auth.disableMFA = function () {
    return __awaiter(this, void 0, void 0, function* () {
        const { user } = yield Auth.getCurrentSessionUser();
        yield this.updateUserAttribute("custom:backupPhraseMFA", "false");
        const smsMfaSettings = {
            PreferredMfa: false,
            Enabled: false,
        };
        const totpMfaSettings = {
            PreferredMfa: false,
            Enabled: false,
        };
        yield new Promise((resolve, reject) => user.setUserMfaPreference(smsMfaSettings, totpMfaSettings, function (err, result) {
            if (err) {
                reject(err);
            }
            resolve(user);
        }));
    });
};
Auth.registerPhoneNumber = function (phoneNumber) {
    return __awaiter(this, void 0, void 0, function* () {
        const { user } = yield Auth.getCurrentSessionUser();
        yield this.updateUserAttribute("phone_number", phoneNumber);
        yield new Promise((resolve, reject) => user.getAttributeVerificationCode('phone_number', {
            onSuccess: function (result) {
                resolve(result);
            },
            onFailure: function (err) {
                reject(err);
            }
        }));
    });
};
Auth.verifyPhoneNumber = function (verificationCode) {
    return __awaiter(this, void 0, void 0, function* () {
        const { user } = yield Auth.getCurrentSessionUser();
        yield new Promise((resolve, reject) => user.verifyAttribute('phone_number', verificationCode, {
            onSuccess: function (result) {
                resolve(result);
            },
            onFailure: function (err) {
                reject(err);
            }
        }));
    });
};
Auth.associateSoftwareToken = function () {
    return __awaiter(this, void 0, void 0, function* () {
        const { user } = yield Auth.getCurrentSessionUser();
        Auth.user = user;
        return yield new Promise((resolve, reject) => Auth.user.associateSoftwareToken({
            associateSecretCode: function (secretCode) {
                resolve(secretCode);
            },
            onFailure: function (err) {
                reject(err);
            }
        }));
    });
};
Auth.verifySoftwareToken = function (totpCode, deviceName) {
    return __awaiter(this, void 0, void 0, function* () {
        yield new Promise((resolve, reject) => Auth.user.verifySoftwareToken(totpCode, deviceName, {
            onSuccess: function (session) {
                resolve(session);
            },
            onFailure: function (err) {
                reject(err);
            }
        }));
    });
};
Auth.generateAPIKey = function () {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield fetch(`${this.config.apiurl}/api-keys`, {
            method: 'post',
            headers: new Headers({
                'Authorization': yield this.getAuthorization(),
            }),
        });
        return (yield response.json()).apiKey;
    });
};
Auth.getAPIKey = function () {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield fetch(`${this.config.apiurl}/api-keys`, {
            method: 'get',
            headers: new Headers({
                'Authorization': yield this.getAuthorization(),
            }),
        });
        if (response.status === 200) {
            return (yield response.json()).apiKey;
        }
        return null;
    });
};
Auth.deleteAPIKey = function () {
    return __awaiter(this, void 0, void 0, function* () {
        yield fetch(`${this.config.apiurl}/api-keys`, {
            method: 'delete',
            headers: new Headers({
                'Authorization': yield this.getAuthorization(),
            }),
        });
    });
};
Auth.retrieveUserAttributes = function (user) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            user.getUserAttributes(function (err, result) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (err) {
                        reject(err);
                    }
                    const attributes = result.reduce(function (attributesObject, attribute) {
                        attributesObject[attribute.Name] = attribute.Value;
                        return attributesObject;
                    }, {});
                    resolve(attributes);
                });
            });
        });
    });
};
Auth.getCurrentSessionUser = function () {
    return __awaiter(this, void 0, void 0, function* () {
        const cognitoUser = this.pool.getCurrentUser();
        if (cognitoUser === null) {
            throw new Error("Invalid session");
        }
        return new Promise((resolve, reject) => cognitoUser.getSession((err, session) => {
            if (err || !session) {
                reject(err || new Error("Invalid session"));
            }
            resolve({ user: cognitoUser, session });
        }));
    });
};
Auth.authenticateUser = function (email, password) {
    return __awaiter(this, void 0, void 0, function* () {
        const authenticationData = {
            Username: email,
            Password: password,
        };
        Auth.user = this.getCognitoUser(email);
        const authenticationDetails = new amazon_cognito_identity_js_1.AuthenticationDetails(authenticationData);
        return new Promise((resolve, reject) => Auth.user.authenticateUser(authenticationDetails, {
            onSuccess: function (result) {
                resolve({ user: Auth.user, session: result });
            },
            onFailure: function (err) {
                reject(err);
            },
            totpRequired: function (secretCode, challengeParameters) {
                reject({ mfaRequired: true, mfaType: "TOTP", secretCode: secretCode, challengeParameters: challengeParameters });
            },
            mfaRequired: function (_) {
                reject({ mfaRequired: true, mfaType: "SMS" });
            }
        }));
    });
};
Auth.confirmUser = function (verificationCode, mfaType) {
    return __awaiter(this, void 0, void 0, function* () {
        const mfa = mfaType === "TOTP" ? "SOFTWARE_TOKEN_MFA" : null;
        return new Promise((resolve, reject) => Auth.user.sendMFACode(verificationCode, {
            onSuccess: function (result) {
                resolve({ user: Auth.user, session: result });
            },
            onFailure: function (err) {
                reject(err);
            }
        }, mfa));
    });
};
const defaultAuthOptions = {
    env: "v2",
    storage: getDefaultStorage(),
};
function apiConfig(env) {
    switch (env) {
        case "dev":
            return {
                apiurl: "https://api.akord.link",
                userPoolId: "eu-central-1_FOAlZvgHo",
                userPoolsWebClientId: "3m7t2tk3dpldemk3geq0otrtt9"
            };
        case "v2":
        default:
            return {
                apiurl: "https://api.akord.com",
                userPoolId: "eu-central-1_glTrP1Kin",
                userPoolsWebClientId: "7u2a1pf5i6shfo7enci6bagk7u"
            };
    }
}
;
function getDefaultStorage() {
    return isServer() ? null : window.sessionStorage;
}
function isServer() {
    return isNode() || isDeno();
}
function isNode() {
    var _a;
    return (typeof process !== 'undefined') && (((_a = process.release) === null || _a === void 0 ? void 0 : _a.name) === 'node');
}
function isDeno() {
    return window && ("Deno" in window);
}
Auth.configure();
