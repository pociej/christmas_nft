"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomContextStrategy = void 0;
const rxjs_1 = require("rxjs");
const promise_cache_buster_decorator_1 = require("../promise.cache-buster.decorator");
const promise_cacheable_decorator_1 = require("../promise.cacheable.decorator");
const promise_cacheable_decorator_2 = require("../promise.cacheable.decorator");
const common_1 = require("../common");
const LocalStorageStrategy_1 = require("../common/LocalStorageStrategy");
const InMemoryStorageStrategy_1 = require("../common/InMemoryStorageStrategy");
const IAsyncStorageStrategy_1 = require("common/IAsyncStorageStrategy");
const cat_1 = require("./cat");
let customStrategySpy = jasmine.createSpy();
class CustomContextStrategy extends InMemoryStorageStrategy_1.InMemoryStorageStrategy {
    add(cachePair, cacheKey, ctx) {
        customStrategySpy(ctx);
        super.add(cachePair, cacheKey, ctx);
    }
    ;
}
exports.CustomContextStrategy = CustomContextStrategy;
jasmine.DEFAULT_TIMEOUT_INTERVAL = 15000;
class AsyncStorageStrategy extends IAsyncStorageStrategy_1.IAsyncStorageStrategy {
    constructor() {
        super(...arguments);
        this.cachePairs = [];
    }
    add(cachePair) {
        this.cachePairs.push(cachePair);
        return Promise.resolve();
    }
    ;
    addMany(cachePairs) {
        this.cachePairs = cachePairs;
        return Promise.resolve();
    }
    ;
    updateAtIndex(index, entity) {
        const updatee = this.cachePairs[index];
        Object.assign(updatee, entity);
        return Promise.resolve();
    }
    update(index, entity) {
        const updatee = this.cachePairs[index];
        Object.assign(updatee, entity);
        return Promise.resolve();
    }
    getAll() {
        return Promise.resolve(this.cachePairs);
    }
    ;
    removeAtIndex(index) {
        this.cachePairs.splice(index, 1);
        return Promise.resolve();
    }
    remove(index) {
        this.cachePairs.splice(index, 1);
        return Promise.resolve();
    }
    removeAll() {
        this.cachePairs.length = 0;
        return Promise.resolve();
    }
}
const strategies = [null, AsyncStorageStrategy, LocalStorageStrategy_1.LocalStorageStrategy];
strategies.forEach(s => {
    const cacheBusterNotifier = new rxjs_1.Subject();
    if (s) {
        common_1.GlobalCacheConfig.storageStrategy = s;
    }
    describe(`${!s ? 'InMemoryStorageStrategy' : s.name}: PCacheableDecorator`, () => {
        let service = null;
        let mockServiceCallSpy = null;
        const cacheModifier = new rxjs_1.Subject();
        beforeEach(() => {
            class Service {
                mockServiceCall(parameter) {
                    return new Promise(resolve => {
                        setTimeout(() => {
                            resolve({ payload: parameter });
                        }, 300);
                    });
                }
                mockSaveServiceCall() {
                    return new Promise(resolve => {
                        setTimeout(() => {
                            resolve('SAVED');
                        }, 300);
                    });
                }
                mockServiceCallWithMultipleParameters(parameter1, parameter2) {
                    return new Promise(resolve => {
                        setTimeout(() => {
                            resolve({ payload: [parameter1, parameter2] });
                        }, 300);
                    });
                }
                getData(parameter) {
                    return this.mockServiceCall(parameter);
                }
                getData1(parameter) {
                    return this.mockServiceCall(parameter);
                }
                getData2(parameter) {
                    return this.mockServiceCall(parameter);
                }
                getData3(parameter) {
                    return this.mockServiceCall(parameter);
                }
                getDataWithParamsObj(parameter) {
                    return this.mockServiceCall(parameter);
                }
                getDataAndReturnCachedStream(parameter) {
                    return this.mockServiceCall(parameter);
                }
                getDataWithExpiration(parameter) {
                    return this.mockServiceCall(parameter);
                }
                getDataWithSlidingExpiration(parameter) {
                    return this.mockServiceCall(parameter);
                }
                getDataWithMaxCacheCount(parameter) {
                    return this.mockServiceCall(parameter);
                }
                getDataWithMaxCacheCountAndExpiration(parameter) {
                    return this.mockServiceCall(parameter);
                }
                getDataWithMaxCacheCountAndSlidingExpiration(parameter) {
                    return this.mockServiceCall(parameter);
                }
                getDataWithCustomCacheResolver(parameter, _cacheRerouterParameter) {
                    return this.mockServiceCall(parameter);
                }
                getDataWithCustomCacheResolverAndHasher(parameter) {
                    return this.mockServiceCall(parameter);
                }
                getWithAComplexType(parameter) {
                    return this.mockServiceCall(parameter);
                }
                getDataWithCustomCacheDecider(parameter) {
                    return this.mockServiceCall(parameter);
                }
                saveDataAndCacheBust() {
                    return this.mockSaveServiceCall();
                }
                saveDataAndCacheBustWithInstant() {
                    return this.mockSaveServiceCall();
                }
                getDataWithCacheBusting(parameter) {
                    return this.mockServiceCall(parameter);
                }
                getDataWithUndefinedParameter(parameter = '') {
                    return this.mockServiceCall(parameter);
                }
                getDataWithMultipleUndefinedParameters(parameter = 'Parameter1', parameter1 = 'Parameter2') {
                    return this.mockServiceCallWithMultipleParameters(parameter, parameter1);
                }
                getDataWithCustomStorageStrategyProvided(parameter) {
                    return this.mockServiceCall(parameter);
                }
                getMutableData(parameter) {
                    return this.mockServiceCall(parameter);
                }
                getDataWithCustomContextStorageStrategy(parameter = 'Parameter1') {
                    return this.mockServiceCall(parameter);
                }
            }
            __decorate([
                (0, promise_cacheable_decorator_1.PCacheable)()
            ], Service.prototype, "getData", null);
            __decorate([
                (0, promise_cacheable_decorator_1.PCacheable)()
            ], Service.prototype, "getData1", null);
            __decorate([
                (0, promise_cacheable_decorator_1.PCacheable)()
            ], Service.prototype, "getData2", null);
            __decorate([
                (0, promise_cacheable_decorator_1.PCacheable)()
            ], Service.prototype, "getData3", null);
            __decorate([
                (0, promise_cacheable_decorator_1.PCacheable)()
            ], Service.prototype, "getDataWithParamsObj", null);
            __decorate([
                (0, promise_cacheable_decorator_1.PCacheable)()
            ], Service.prototype, "getDataAndReturnCachedStream", null);
            __decorate([
                (0, promise_cacheable_decorator_1.PCacheable)({
                    maxAge: 400
                })
            ], Service.prototype, "getDataWithExpiration", null);
            __decorate([
                (0, promise_cacheable_decorator_1.PCacheable)({
                    maxAge: 400,
                    slidingExpiration: true
                })
            ], Service.prototype, "getDataWithSlidingExpiration", null);
            __decorate([
                (0, promise_cacheable_decorator_1.PCacheable)({
                    maxCacheCount: 5
                })
            ], Service.prototype, "getDataWithMaxCacheCount", null);
            __decorate([
                (0, promise_cacheable_decorator_1.PCacheable)({
                    maxAge: 400,
                    maxCacheCount: 5
                })
            ], Service.prototype, "getDataWithMaxCacheCountAndExpiration", null);
            __decorate([
                (0, promise_cacheable_decorator_1.PCacheable)({
                    maxAge: 400,
                    maxCacheCount: 5,
                    slidingExpiration: true
                })
            ], Service.prototype, "getDataWithMaxCacheCountAndSlidingExpiration", null);
            __decorate([
                (0, promise_cacheable_decorator_1.PCacheable)({
                    cacheResolver: (_oldParameters, newParameters) => {
                        return newParameters.find((param) => !!param.straightToLastCache);
                    }
                })
            ], Service.prototype, "getDataWithCustomCacheResolver", null);
            __decorate([
                (0, promise_cacheable_decorator_1.PCacheable)({
                    cacheHasher: (_parameters) => _parameters[0] * 2,
                    cacheResolver: (oldParameter, newParameter) => {
                        return newParameter > 5;
                    }
                })
            ], Service.prototype, "getDataWithCustomCacheResolverAndHasher", null);
            __decorate([
                (0, promise_cacheable_decorator_1.PCacheable)()
            ], Service.prototype, "getWithAComplexType", null);
            __decorate([
                (0, promise_cacheable_decorator_1.PCacheable)({
                    shouldCacheDecider: (response) => {
                        return response.payload === 'test';
                    }
                })
            ], Service.prototype, "getDataWithCustomCacheDecider", null);
            __decorate([
                (0, promise_cache_buster_decorator_1.PCacheBuster)({
                    cacheBusterNotifier: cacheBusterNotifier
                })
            ], Service.prototype, "saveDataAndCacheBust", null);
            __decorate([
                (0, promise_cache_buster_decorator_1.PCacheBuster)({
                    cacheBusterNotifier: cacheBusterNotifier,
                    isInstant: true
                })
            ], Service.prototype, "saveDataAndCacheBustWithInstant", null);
            __decorate([
                (0, promise_cacheable_decorator_1.PCacheable)({
                    cacheBusterObserver: cacheBusterNotifier.asObservable()
                })
            ], Service.prototype, "getDataWithCacheBusting", null);
            __decorate([
                (0, promise_cacheable_decorator_1.PCacheable)()
            ], Service.prototype, "getDataWithUndefinedParameter", null);
            __decorate([
                (0, promise_cacheable_decorator_1.PCacheable)()
            ], Service.prototype, "getDataWithMultipleUndefinedParameters", null);
            __decorate([
                (0, promise_cacheable_decorator_1.PCacheable)({
                    maxAge: 400,
                    slidingExpiration: true,
                    storageStrategy: InMemoryStorageStrategy_1.InMemoryStorageStrategy
                })
            ], Service.prototype, "getDataWithCustomStorageStrategyProvided", null);
            __decorate([
                (0, promise_cacheable_decorator_1.PCacheable)({
                    storageStrategy: InMemoryStorageStrategy_1.InMemoryStorageStrategy,
                    cacheModifier
                })
            ], Service.prototype, "getMutableData", null);
            __decorate([
                (0, promise_cacheable_decorator_1.PCacheable)({
                    storageStrategy: CustomContextStrategy
                })
            ], Service.prototype, "getDataWithCustomContextStorageStrategy", null);
            service = new Service();
            mockServiceCallSpy = spyOn(service, 'mockServiceCall').and.callThrough();
            if (common_1.GlobalCacheConfig.storageStrategy === LocalStorageStrategy_1.LocalStorageStrategy) {
                localStorage.clear();
            }
        });
        it('return cached data up until a new parameter is passed and the cache is busted', () => __awaiter(void 0, void 0, void 0, function* () {
            const asyncFreshData = yield service.getData('test');
            expect(asyncFreshData).toEqual({ payload: 'test' });
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(1);
            const cachedResponse = yield service.getData('test');
            expect(cachedResponse).toEqual({ payload: 'test' });
            /**
             * response acquired from cache, so no incrementation on the service spy call counter is expected here
             */
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(1);
            yield service.getData('test2');
            /**
             * no cache for 'test2', but service call was made so the spy counter is incremented
             */
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(2);
            const cachedResponse3 = yield service.getData('test3');
            // /**
            //  * service call is made and waited out
            //  */
            expect(cachedResponse3).toEqual({ payload: 'test3' });
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(3);
            /**
             * this should NOT return cached response, since the currently cached one should be 'test3'
             */
            yield service.getData('test');
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(4);
        }));
        it('returns promises in cache with a referential type params', (done) => __awaiter(void 0, void 0, void 0, function* () {
            let params = {
                number: [1]
            };
            /**
             * call the service endpoint with current params values
             */
            yield service.getDataWithParamsObj(params);
            /**
             * change params object values
             */
            params.number.push(2);
            /**
             * call again..
             */
            yield service.getDataWithParamsObj(params);
            /**
             * service call count should still be 2, since param object has changed
             */
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(2);
            done();
        }));
        it('return the cached observable up until it completes or errors', (done) => __awaiter(void 0, void 0, void 0, function* () {
            /**
             * call the service endpoint five hundred times with the same parameter
             * but the service should only be called once, since the observable will be cached
             */
            for (let i = 0; i < 500; i++) {
                yield service.getDataAndReturnCachedStream('test');
            }
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(1);
            setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {
                /**
                 * call again..
                 */
                yield service.getDataAndReturnCachedStream('test');
                /**
                 * service call count should still be 1, since we are returning from cache now
                 */
                expect(mockServiceCallSpy).toHaveBeenCalledTimes(1);
                done();
            }), 1000);
        }));
        it('return cached date up until the maxAge period has passed and then bail out to data source', (done) => __awaiter(void 0, void 0, void 0, function* () {
            const asyncFreshData = yield service.getDataWithExpiration('test');
            expect(asyncFreshData).toEqual({ payload: 'test' });
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(1);
            const cachedResponse = yield service.getDataWithExpiration('test');
            expect(cachedResponse).toEqual({ payload: 'test' });
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(1);
            setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {
                /**
                 * after 500ms the cache would've expired and we will bail to the data source
                 */
                yield service.getDataWithExpiration('test');
                expect(mockServiceCallSpy).toHaveBeenCalledTimes(2);
                done();
            }), 500);
        }));
        it('return cached data up until the maxAge period but renew the expiration if called within the period', (done) => __awaiter(void 0, void 0, void 0, function* () {
            const asyncFreshData = yield service.getDataWithSlidingExpiration('test');
            expect(asyncFreshData).toEqual({ payload: 'test' });
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(1);
            const cachedResponse = yield service.getDataWithSlidingExpiration('test');
            expect(cachedResponse).toEqual({ payload: 'test' });
            /**
             * call count should still be one, since we rerouted to cache, instead of service call
             */
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(1);
            setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {
                yield service.getDataWithSlidingExpiration('test');
                expect(mockServiceCallSpy).toHaveBeenCalledTimes(1);
                setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {
                    yield service.getDataWithSlidingExpiration('test');
                    expect(mockServiceCallSpy).toHaveBeenCalledTimes(2);
                    done();
                }), 500);
            }), 200);
        }));
        it('return cached data for 5 unique requests, then should bail to data source', () => __awaiter(void 0, void 0, void 0, function* () {
            /**
             * call the same endpoint with 5 different parameters and cache all 5 responses, based on the maxCacheCount parameter
             */
            const parameters = ['test1', 'test2', 'test3', 'test4', 'test5'];
            yield Promise.all(parameters.map(param => (service.getDataWithMaxCacheCount(param))));
            /**
             * data for all endpoints should be available through cache by now
             */
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(5);
            const cachedResponse = yield service.getDataWithMaxCacheCount('test1');
            expect(cachedResponse).toEqual({ payload: 'test1' });
            /** call count still 5 */
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(5);
            /**
             * this should return a maximum of 5 different cached responses
             */
            const cachedResponseAll = yield Promise.all(parameters.map(param => service.getDataWithMaxCacheCount(param)));
            expect(cachedResponseAll).toEqual([
                { payload: 'test1' },
                { payload: 'test2' },
                { payload: 'test3' },
                { payload: 'test4' },
                { payload: 'test5' }
            ]);
            /** call count still 5 */
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(5);
            const asyncData = yield service.getDataWithMaxCacheCount('test6');
            expect(asyncData).toEqual({ payload: 'test6' });
            /** call count incremented by one */
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(6);
            /**
             * by now the response for test6 should be cached and the one for test1 should be free for GC..
             */
            const newParameters = ['test2', 'test3', 'test4', 'test5', 'test6'];
            /**
             * this should return a maximum of 5 different cached responses, with the latest one in the end
             */
            const cachedResponseAll2 = yield Promise.all(newParameters.map(param => service.getDataWithMaxCacheCount(param)));
            expect(cachedResponseAll2).toEqual([
                { payload: 'test2' },
                { payload: 'test3' },
                { payload: 'test4' },
                { payload: 'test5' },
                { payload: 'test6' }
            ]);
            /** no service calls will be made, since we have all the responses still cached even after 1s (1000ms) */
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(6);
            /**
             * fetch and cache the test7 response
             */
            const nonCachedResponse = yield service.getDataWithMaxCacheCount('test7');
            expect(nonCachedResponse).toEqual({ payload: 'test7' });
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(7);
            /**
             * since the cached response for 'test2' was now removed from cache by 'test7',
             */
            yield service.getDataWithMaxCacheCount('test2');
            /**
             * test2 is not in cache anymore and a service call will be made
             */
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(8);
        }));
        it('return cached data for 5 unique requests all available for 7500ms', (done) => __awaiter(void 0, void 0, void 0, function* () {
            /**
             * call the same endpoint with 5 different parameters and cache all 5 responses, based on the maxCacheCount parameter
             */
            const parameters = ['test1', 'test2', 'test3', 'test4', 'test5'];
            const cachedResponse2 = yield Promise.all(parameters.map(param => service.getDataWithMaxCacheCountAndExpiration(param)));
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(5);
            expect(cachedResponse2).toEqual([
                { payload: 'test1' },
                { payload: 'test2' },
                { payload: 'test3' },
                { payload: 'test4' },
                { payload: 'test5' }
            ]);
            setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {
                yield service.getDataWithMaxCacheCountAndExpiration('test1');
                /**
                 * by now, no cache exists for the 'test1' parameter, so 1 more call will be made to the service
                 */
                expect(mockServiceCallSpy).toHaveBeenCalledTimes(6);
                done();
            }), 500);
        }));
        it('return cached data up until new parameters are passed WITH a custom resolver function', () => __awaiter(void 0, void 0, void 0, function* () {
            const asyncFreshData = yield service.getDataWithCustomCacheResolver('test1');
            expect(asyncFreshData).toEqual({ payload: 'test1' });
            expect(mockServiceCallSpy).toHaveBeenCalled();
            const asyncFreshData2 = yield service.getDataWithCustomCacheResolver('test2');
            expect(asyncFreshData2).toEqual({ payload: 'test2' });
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(2);
            const cachedResponse = yield service.getDataWithCustomCacheResolver('test3', {
                straightToLastCache: true
            });
            expect(cachedResponse).toEqual({ payload: 'test2' });
            /**
             * call count still 2, since we rerouted directly to cache
             */
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(2);
            yield service.getDataWithCustomCacheResolver('test3');
            /**no cache reerouter -> bail to service call -> increment call counter*/
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(3);
        }));
        it('only cache data when a specific response is returned, otherwise it should bail to service call', () => __awaiter(void 0, void 0, void 0, function* () {
            const asyncData = yield service.getDataWithCustomCacheDecider('test1');
            expect(asyncData).toEqual({ payload: 'test1' });
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(1);
            yield service.getDataWithCustomCacheDecider('test1');
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(2);
            /**
             * next calls will be for 'test' whose response will match the cache deciders condition and it will be cached
             */
            const asyncData2 = yield service.getDataWithCustomCacheDecider('test');
            expect(asyncData2).toEqual({ payload: 'test' });
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(3);
            /**
             * this call has to return cached data, since we the response cache decider should have matched the previous one
             */
            const cachedData2 = yield service.getDataWithCustomCacheDecider('test');
            expect(cachedData2).toEqual({ payload: 'test' });
            /**
             * the service call count won't be incremented
             */
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(3);
        }));
        it('cache data until the cacheBusterNotifier has emitted', () => __awaiter(void 0, void 0, void 0, function* () {
            const asyncFreshData = yield service.getDataWithCacheBusting('test');
            expect(asyncFreshData).toEqual({ payload: 'test' });
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(1);
            const cachedResponse = yield service.getDataWithCacheBusting('test');
            expect(cachedResponse).toEqual({ payload: 'test' });
            /**
             * response acquired from cache, so no incrementation on the service spy call counter is expected here
             */
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(1);
            /**
             * make the save call
             * after 1 second the cache busting subject will emit and the cache for getDataWithCacheBusting('test') will be relieved of
             */
            expect(yield service.saveDataAndCacheBust()).toEqual('SAVED');
            yield service.getDataWithCacheBusting('test');
            /**
             * call count has incremented due to the actual method call (instead of cache)
             */
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(2);
            /**
             * pass through 1s of time
             */
            /**
             * synchronous cached response should now be returned
             */
            expect(yield service.getDataWithCacheBusting('test')).toEqual({
                payload: 'test'
            });
        }));
        it('cache data until the cacheBusterNotifier has emitted { isInstant: true }', () => __awaiter(void 0, void 0, void 0, function* () {
            const asyncFreshData = yield service.getDataWithCacheBusting('test');
            expect(asyncFreshData).toEqual({ payload: 'test' });
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(1);
            const cachedResponse = yield service.getDataWithCacheBusting('test');
            expect(cachedResponse).toEqual({ payload: 'test' });
            /**
             * response acquired from cache, so no incrementation on the service spy call counter is expected here
             */
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(1);
            /**
             * make the save call
             * cache busting subject will emit instantly and the cache for getDataWithCacheBusting('test') will be relieved of
             */
            const promise = service.saveDataAndCacheBustWithInstant();
            yield service.getDataWithCacheBusting('test');
            /**
             * call count has incremented due to the actual method call (instead of cache)
             */
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(2);
            /**
            * expect promise to return original data
            **/
            expect(yield promise).toEqual('SAVED');
            /**
             * pass through 1s of time
             */
            /**
             * synchronous cached response should now be returned
             */
            expect(yield service.getDataWithCacheBusting('test')).toEqual({
                payload: 'test'
            });
        }));
        it('should clear all caches when the global cache buster is called', () => __awaiter(void 0, void 0, void 0, function* () {
            /**
             * call the first method and cache it
             */
            service.getData('test1');
            const asyncFreshData1 = yield (service.getData('test1'));
            expect(asyncFreshData1).toEqual({ payload: 'test1' });
            const cachedResponse1 = yield (service.getData('test1'));
            expect(cachedResponse1).toEqual({ payload: 'test1' });
            /**
             * even though we called getData twice, this should only be called once
             * since the second call went straight to the cache
             */
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(1);
            service.getData('test2');
            const asyncFreshData2 = yield (service.getData('test2'));
            expect(asyncFreshData2).toEqual({ payload: 'test2' });
            const cachedResponse2 = yield (service.getData('test2'));
            expect(cachedResponse2).toEqual({ payload: 'test2' });
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(2);
            service.getData('test3');
            const asyncFreshData3 = yield (service.getData('test3'));
            expect(asyncFreshData3).toEqual({ payload: 'test3' });
            const cachedResponse3 = yield (service.getData('test3'));
            expect(cachedResponse3).toEqual({ payload: 'test3' });
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(3);
            /**
             * bust all caches
             */
            promise_cacheable_decorator_2.promiseGlobalCacheBusterNotifier.next();
            yield (service.getData('test1'));
            yield (service.getData('test2'));
            yield (service.getData('test3'));
            /**
             * if we didn't bust the cache, this would've been 3
             */
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(6);
        }));
        it('should not change undefined parameters to null', () => __awaiter(void 0, void 0, void 0, function* () {
            yield service.getDataWithUndefinedParameter(undefined);
            expect(mockServiceCallSpy).toHaveBeenCalledWith('');
            yield service.getDataWithUndefinedParameter();
            expect(mockServiceCallSpy).toHaveBeenCalledWith('');
            let mockServiceCallWithMultipleParametersSpy = spyOn(service, 'mockServiceCallWithMultipleParameters').and.callThrough();
            yield service.getDataWithMultipleUndefinedParameters(undefined, undefined);
            expect(mockServiceCallWithMultipleParametersSpy).toHaveBeenCalledWith('Parameter1', 'Parameter2');
            const asyncData = yield service.getDataWithMultipleUndefinedParameters(undefined, undefined);
            expect(asyncData).toEqual({ payload: ['Parameter1', 'Parameter2'] });
            expect(mockServiceCallWithMultipleParametersSpy).toHaveBeenCalledWith('Parameter1', 'Parameter2');
            yield service.getDataWithMultipleUndefinedParameters(undefined, undefined);
            expect(mockServiceCallWithMultipleParametersSpy).toHaveBeenCalledTimes(1);
            yield service.getDataWithMultipleUndefinedParameters('Parameter1', undefined);
            expect(mockServiceCallWithMultipleParametersSpy).toHaveBeenCalledTimes(2);
        }));
        it('should work correctly with a custom storage strategy', (done) => __awaiter(void 0, void 0, void 0, function* () {
            //for some reason we cant rely on expectations on the other methods here
            const getAllSpy = spyOn(InMemoryStorageStrategy_1.InMemoryStorageStrategy.prototype, 'getAll').and.callThrough();
            const asyncFreshData = yield service.getDataWithCustomStorageStrategyProvided('test');
            expect(asyncFreshData).toEqual({ payload: 'test' });
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(1);
            // one add call, one getAll call
            expect(getAllSpy).toHaveBeenCalledTimes(1);
            const cachedResponse = yield service.getDataWithCustomStorageStrategyProvided('test');
            expect(cachedResponse).toEqual({ payload: 'test' });
            expect(getAllSpy).toHaveBeenCalledTimes(2);
            /**
             * call count should still be one, since we rerouted to cache, instead of service call
             */
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(1);
            setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {
                yield service.getDataWithCustomStorageStrategyProvided('test');
                expect(mockServiceCallSpy).toHaveBeenCalledTimes(1);
                // three getAll calls since every time we call the decorated method, we check the cache first
                expect(getAllSpy).toHaveBeenCalledTimes(3);
                setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {
                    yield service.getDataWithCustomStorageStrategyProvided('test');
                    expect(mockServiceCallSpy).toHaveBeenCalledTimes(2);
                    done();
                }), 500);
            }), 200);
        }));
        it('return cached data up until new parameters are passed WITH a custom resolver and hasher function', () => __awaiter(void 0, void 0, void 0, function* () {
            // call once and cache with 3
            yield service.getDataWithCustomCacheResolverAndHasher(3);
            // call twice with 3 and reuse the cached values because of 
            // the custom cache resolver passed to the decorator, i.e - 3 * 2 > 5
            yield service.getDataWithCustomCacheResolverAndHasher(3);
            yield service.getDataWithCustomCacheResolverAndHasher(3);
            // call 4 times with an uncashed parameter 2
            yield service.getDataWithCustomCacheResolverAndHasher(2);
            yield service.getDataWithCustomCacheResolverAndHasher(2);
            yield service.getDataWithCustomCacheResolverAndHasher(2);
            yield service.getDataWithCustomCacheResolverAndHasher(2);
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(5);
        }));
        it('return cached data up until new parameters are passed WITH a custom GLOBAL resolver and hasher function', () => __awaiter(void 0, void 0, void 0, function* () {
            common_1.GlobalCacheConfig.cacheHasher = (_parameters) => _parameters[0] + '__wehoo';
            common_1.GlobalCacheConfig.cacheResolver = (oldParameter, newParameter) => {
                return newParameter === 'cached__wehoo';
            };
            class Service {
                mockServiceCall(parameter) {
                    return new Promise(resolve => {
                        setTimeout(() => {
                            resolve({ payload: parameter });
                        }, 300);
                    });
                }
                getData(parameter) {
                    return this.mockServiceCall(parameter);
                }
            }
            __decorate([
                (0, promise_cacheable_decorator_1.PCacheable)()
            ], Service.prototype, "getData", null);
            const service = new Service();
            mockServiceCallSpy = spyOn(service, 'mockServiceCall').and.callThrough();
            // call once and cache with cached
            yield service.getData('cached');
            // call twice with cached and reuse the cached values
            yield service.getData('cached');
            yield service.getData('cached');
            // call 4 times with an uncashed parameter 2
            yield service.getData('not-cached');
            yield service.getData('not-cached');
            yield service.getData('not-cached');
            yield service.getData('not-cached');
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(5);
            common_1.GlobalCacheConfig.cacheHasher = undefined;
            common_1.GlobalCacheConfig.cacheResolver = undefined;
        }));
        it('should call a function with a complex instance which should not be touched and passed to the original method as it is', () => __awaiter(void 0, void 0, void 0, function* () {
            const complexObject = new cat_1.Cat();
            complexObject.name = 'Felix';
            const response = yield service.getWithAComplexType(complexObject);
            expect(service.mockServiceCall).toHaveBeenCalledWith(complexObject);
            // object method would not exist if we have mutated the parameter through the DEFAULT_CACHE_RESOLVER
            expect(response.payload.meow("I am hungry!")).toBe("Felix says I am hungry!");
        }));
        it('use the maxAge and slidingExpiration from the GlobalCacheConfig', (done) => __awaiter(void 0, void 0, void 0, function* () {
            common_1.GlobalCacheConfig.maxAge = 400;
            common_1.GlobalCacheConfig.slidingExpiration = true;
            const asyncFreshData = yield service.getData1('test');
            expect(asyncFreshData).toEqual({ payload: 'test' });
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(1);
            const cachedResponse = yield service.getData1('test');
            expect(cachedResponse).toEqual({ payload: 'test' });
            /**
             * call count should still be one, since we rerouted to cache, instead of service call
             */
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(1);
            setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {
                yield service.getData1('test');
                expect(mockServiceCallSpy).toHaveBeenCalledTimes(1);
                setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {
                    yield service.getData1('test');
                    expect(mockServiceCallSpy).toHaveBeenCalledTimes(2);
                    done();
                    common_1.GlobalCacheConfig.maxAge = undefined;
                    common_1.GlobalCacheConfig.slidingExpiration = undefined;
                }), 500);
            }), 200);
        }));
        it('use the maxCacheCount from the GlobalCacheConfig', () => __awaiter(void 0, void 0, void 0, function* () {
            common_1.GlobalCacheConfig.maxCacheCount = 5;
            /**
             * call the same endpoint with 5 different parameters and cache all 5 responses, based on the maxCacheCount parameter
             */
            const parameters = ['test1', 'test2', 'test3', 'test4', 'test5'];
            yield Promise.all(parameters.map(param => (service.getData2(param))));
            /**
             * data for all endpoints should be available through cache by now
             */
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(5);
            const cachedResponse = yield service.getData2('test1');
            expect(cachedResponse).toEqual({ payload: 'test1' });
            /** call count still 5 */
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(5);
            /**
             * this should return a maximum of 5 different cached responses
             */
            const cachedResponseAll = yield Promise.all(parameters.map(param => service.getData2(param)));
            expect(cachedResponseAll).toEqual([
                { payload: 'test1' },
                { payload: 'test2' },
                { payload: 'test3' },
                { payload: 'test4' },
                { payload: 'test5' }
            ]);
            /** call count still 5 */
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(5);
            const asyncData = yield service.getData2('test6');
            expect(asyncData).toEqual({ payload: 'test6' });
            /** call count incremented by one */
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(6);
            /**
             * by now the response for test6 should be cached and the one for test1 should be free for GC..
             */
            const newParameters = ['test2', 'test3', 'test4', 'test5', 'test6'];
            /**
             * this should return a maximum of 5 different cached responses, with the latest one in the end
             */
            const cachedResponseAll2 = yield Promise.all(newParameters.map(param => service.getData2(param)));
            expect(cachedResponseAll2).toEqual([
                { payload: 'test2' },
                { payload: 'test3' },
                { payload: 'test4' },
                { payload: 'test5' },
                { payload: 'test6' }
            ]);
            /** no service calls will be made, since we have all the responses still cached even after 1s (1000ms) */
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(6);
            /**
             * fetch and cache the test7 response
             */
            const nonCachedResponse = yield service.getData2('test7');
            expect(nonCachedResponse).toEqual({ payload: 'test7' });
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(7);
            /**
             * since the cached response for 'test2' was now removed from cache by 'test7',
             */
            yield service.getData2('test2');
            /**
             * test2 is not in cache anymore and a service call will be made
             */
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(8);
            common_1.GlobalCacheConfig.maxCacheCount = undefined;
        }));
        it('use the maxAge from the GlobalCacheConfig', (done) => __awaiter(void 0, void 0, void 0, function* () {
            common_1.GlobalCacheConfig.maxAge = 1000;
            const asyncFreshData = yield service.getData3('test');
            expect(asyncFreshData).toEqual({ payload: 'test' });
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(1);
            const cachedResponse = yield service.getData3('test');
            expect(cachedResponse).toEqual({ payload: 'test' });
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(1);
            setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {
                /**
                 * after 1001ms the cache would've expired and we will bail to the data source
                 */
                yield service.getData3('test');
                expect(mockServiceCallSpy).toHaveBeenCalledTimes(2);
                common_1.GlobalCacheConfig.maxAge = undefined;
                done();
            }), 1001);
        }));
        it('should modify cache of getMutableData dynamically', () => __awaiter(void 0, void 0, void 0, function* () {
            const asyncFreshData = yield service.getMutableData('test');
            expect(asyncFreshData).toEqual({ payload: 'test' });
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(1);
            const cachedResponse = yield service.getMutableData('test');
            expect(cachedResponse).toEqual({ payload: 'test' });
            cacheModifier.next((data) => {
                data.find(p => p.parameters[0] === 'test').response.payload = 'test_modified';
                return data;
            });
            const cachedResponse2 = yield service.getMutableData('test');
            expect(cachedResponse2).toEqual({ payload: 'test_modified' });
            /**
             * response acquired from cache, so no incrementation on the service spy call counter is expected here
             */
            expect(mockServiceCallSpy).toHaveBeenCalledTimes(1);
        }));
        it('should work with a custom context storage strategy', () => __awaiter(void 0, void 0, void 0, function* () {
            yield service.getDataWithCustomContextStorageStrategy('test');
            expect(customStrategySpy).toHaveBeenCalledWith(jasmine.any(Object));
        }));
    });
});
//# sourceMappingURL=promise-cacheable.decorator.spec.js.map